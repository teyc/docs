{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#. If you've not heard of SAFE before, please feel free to start with the introduction . Alternatively, you can immediately try out the quick start guide and tutorial, or simply browse through the documentation. If there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the GitHub repository . We hope you enjoy using SAFE as much as we do! The SAFE team.","title":"Home"},{"location":"component-azure/","text":"Azure in SAFE What is Azure? Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions. How does Azure integrate with SAFE? Azure provides a number of flexible services for SAFE applications, including (but not only): Hosting Services Azure comes with several ready-made hosting services, including App Service , which enables seamless hosting of web applications, including ASP .NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes , which work fantastically well with SAFE. Platform Services Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including: Compute services such as Azure Functions , for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines . Storage services such as Azure Storage and Data Lake , for storing virtually limitless volumes of data in unstructured or structure form. Database services, including managed SQL Server , MySQL and Postgres , as well as CosmosDB for document and graph stores, Redis and more. Messaging services including Queues , Service Bus and Event Hub . Analytical services such as Stream Analytics , Databricks , Machine Learning and Analysis Services . Security services such as Key Vault and Active Directory . Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the Azure Storage Type Provider provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# (currently not yet supported on .NET Core) .","title":"Learn about Azure"},{"location":"component-azure/#azure-in-safe","text":"","title":"Azure in SAFE"},{"location":"component-azure/#what-is-azure","text":"Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.","title":"What is Azure?"},{"location":"component-azure/#how-does-azure-integrate-with-safe","text":"Azure provides a number of flexible services for SAFE applications, including (but not only):","title":"How does Azure integrate with SAFE?"},{"location":"component-azure/#hosting-services","text":"Azure comes with several ready-made hosting services, including App Service , which enables seamless hosting of web applications, including ASP .NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes , which work fantastically well with SAFE.","title":"Hosting Services"},{"location":"component-azure/#platform-services","text":"Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including: Compute services such as Azure Functions , for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines . Storage services such as Azure Storage and Data Lake , for storing virtually limitless volumes of data in unstructured or structure form. Database services, including managed SQL Server , MySQL and Postgres , as well as CosmosDB for document and graph stores, Redis and more. Messaging services including Queues , Service Bus and Event Hub . Analytical services such as Stream Analytics , Databricks , Machine Learning and Analysis Services . Security services such as Key Vault and Active Directory . Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the Azure Storage Type Provider provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# (currently not yet supported on .NET Core) .","title":"Platform Services"},{"location":"component-elmish/","text":"Elmish in SAFE What is Elmish? Elmish is a set of simple abstractions for writing user interfaces in F# applications in a functional style following the model-view-update architecture made famous by Elm . The Elmish library is not coupled to any specific view engine, but is intended for use in conjuction with a DOM/renderer such as React/ReactNative or VirtualDOM. How does Elmish integrate with SAFE? Elmish provides the ability to more easily create user interfaces in the browser on top of Fable so that you don't have to write applications that are tightly coupled to HTML using e.g. JQuery or similar. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface. This conceptual diagram illustrates how your F# is run in the browser in a SAFE app. Learn more about Elmish here .","title":"Learn about Elmish"},{"location":"component-elmish/#elmish-in-safe","text":"","title":"Elmish in SAFE"},{"location":"component-elmish/#what-is-elmish","text":"Elmish is a set of simple abstractions for writing user interfaces in F# applications in a functional style following the model-view-update architecture made famous by Elm . The Elmish library is not coupled to any specific view engine, but is intended for use in conjuction with a DOM/renderer such as React/ReactNative or VirtualDOM.","title":"What is Elmish?"},{"location":"component-elmish/#how-does-elmish-integrate-with-safe","text":"Elmish provides the ability to more easily create user interfaces in the browser on top of Fable so that you don't have to write applications that are tightly coupled to HTML using e.g. JQuery or similar. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface. This conceptual diagram illustrates how your F# is run in the browser in a SAFE app. Learn more about Elmish here .","title":"How does Elmish integrate with SAFE?"},{"location":"component-fable/","text":"Fable in SAFE What is Fable? Fable is an F#-to-JavaScript (JS) compiler powered by Babel , designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well the most commonly used .NET APIs. How does Fable integrate with SAFE? Fable is much more than an F#-to-JS compiler - it also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. There are two \"sides\" to Fable that work together to allow F# to run within the JS world - a .NET tooling component and a JS tooling component: It's important to understand the Fable is not simply an application that takes in F# and emits JS - instead, the dotnet fable application emits an intermediary file (a Babel Abstract Syntax Tree), which in turn is converted by webpack into well-written JS. Fable and webpack Fable's \"JavaScript\" side is normally hosted within the context of webpack , a powerful bundling tool. You'll normally see a webpack.config.js file in the client folder of your SAFE applications. This file tells webpack how to emit JS from F# files and hosts the Fable webpack plugin, fable-loader . Using webpack also provides many advantages - for example, we as developers can control how JS is rendered through standard tools that exist in the JS ecosystem, whilst also using features such as Hot Module replacement and Source Maps. Creating a webpack config file isn't the easiest thing in the world, so the SAFE Template already has one pre-built that contains the basics to get you up and running immediately. Learn more about Fable here .","title":"Learn about Fable"},{"location":"component-fable/#fable-in-safe","text":"","title":"Fable in SAFE"},{"location":"component-fable/#what-is-fable","text":"Fable is an F#-to-JavaScript (JS) compiler powered by Babel , designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well the most commonly used .NET APIs.","title":"What is Fable?"},{"location":"component-fable/#how-does-fable-integrate-with-safe","text":"Fable is much more than an F#-to-JS compiler - it also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. There are two \"sides\" to Fable that work together to allow F# to run within the JS world - a .NET tooling component and a JS tooling component: It's important to understand the Fable is not simply an application that takes in F# and emits JS - instead, the dotnet fable application emits an intermediary file (a Babel Abstract Syntax Tree), which in turn is converted by webpack into well-written JS.","title":"How does Fable integrate with SAFE?"},{"location":"component-fable/#fable-and-webpack","text":"Fable's \"JavaScript\" side is normally hosted within the context of webpack , a powerful bundling tool. You'll normally see a webpack.config.js file in the client folder of your SAFE applications. This file tells webpack how to emit JS from F# files and hosts the Fable webpack plugin, fable-loader . Using webpack also provides many advantages - for example, we as developers can control how JS is rendered through standard tools that exist in the JS ecosystem, whilst also using features such as Hot Module replacement and Source Maps. Creating a webpack config file isn't the easiest thing in the world, so the SAFE Template already has one pre-built that contains the basics to get you up and running immediately. Learn more about Fable here .","title":"Fable and webpack"},{"location":"component-saturn/","text":"Saturn in SAFE Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components: Giraffe , an F#-specific library for writing functional-first web applications. Microsoft's ASP .NET Core . Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication. Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix . How does Saturn integrate with SAFE? Saturn provides the ability to drive your SAFE applications from the server. It enables: Routing and hosting of your server-side APIs through a set of simple-to-use abstractions. Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable. Other cross cutting concerns e.g. authentication etc. It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here . Learn more about Saturn here .","title":"Learn about Saturn"},{"location":"component-saturn/#saturn-in-safe","text":"Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components: Giraffe , an F#-specific library for writing functional-first web applications. Microsoft's ASP .NET Core . Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication. Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix .","title":"Saturn in SAFE"},{"location":"component-saturn/#how-does-saturn-integrate-with-safe","text":"Saturn provides the ability to drive your SAFE applications from the server. It enables: Routing and hosting of your server-side APIs through a set of simple-to-use abstractions. Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable. Other cross cutting concerns e.g. authentication etc. It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here . Learn more about Saturn here .","title":"How does Saturn integrate with SAFE?"},{"location":"events/","text":"Upcoming events Title Type Date Location Who Cost Past events 2019 Title Type Date Location Who Cost SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 22 2019 Dresden, Germany Compositional IT Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 23 2019 Prague, Czech Republic Compositional IT Free Web development with SAFE Stack Conference Jan 26 2019 Minsk, Belarus Mikhail Smal Paid Hacking F# in JS ecosystem Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free Reinventing MVC pattern for web programming with F# Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Feb 12 2019 Osnabr\u00fcck, Germany Compositional IT Free SAFE web development with F# User Group Mar 28 2019 Prague, Czech Republic Mikhail Smal Free SAFE Stack: Current State Conference April 4-5 2019 London, UK Tomasz Heimowski Paid Workshop: Up and Running with the SAFE Stack Conference April 4-5 2019 London, UK Compositional IT Paid The Pit of Success with SAFE Stack User Group April 11 2019 Berlin, Germany Isaac Abraham Free Workshop: Hands on with F# Conference workshop April 27 2019 Berlin, Germany Isaac Abraham Free Workshop: SAFE Web development with F# Conference May 14 2019 Vilnius, Lithuania Mikhail Smal Paid Write Your Own Domain Specific Language with F# Conference May 15-16 2019 Vilnius, Lithuania Mikhail Smal Paid Full Stack Web in F# Conference June 8 2019 Minsk, Belarus Tomasz Heimowski Paid Write Your Own Domain Specific Language with F# Conference Jun 18 2019 Oslo, Norway Mikhail Smal Paid FableConf Conference Sep 6-7 2019 Antwerp, Belgium Paid Functional Web Programming with the SAFE Stack Training Sep 12-13 2019 London, UK Isaac Abraham / Compositional IT Paid Hands-on with SAFE Stack Conference Oct 17-18 2019 C\u00e1diz, Spain Tomasz Heimowski Paid Full Stack Web in F# Conference November 6-8 2019 Malm\u00f6, Sweden Tomasz Heimowski Paid 2018 Title Type Date Location Who Cost SAFE apps with F# web stack Conference Feb 23 2018 Krak\u00f3w, Poland Tomasz Heimowski Paid SAFE apps with F# web stack Conference April 5 2018 London, UK Tomasz Heimowski Paid SAFE Stack Workshop User Group Aug 22 2018 Bristol, UK Compositional IT Free SAFE apps with F# web stack Conference Sep 21 2018 Gda\u0144sk, Poland Tomasz Heimowski Free SAFE Stack: Functional Web Programming in .NET Conference Sep 22 2018 Cambridge, UK Compositional IT Free F# Full Stack with SAFE Training Sep 26 2018 San Francisco, USA Lambda Factory Paid SAFE Hackday Training Oct 6 2018 Birmingham, UK Ian Russel Free Cloud Programming with F# Training Oct 25 2018 Berlin, Germany Compositional IT Paid FableConf / RemmiDemmi Conference Oct 26/27 2018 Berlin, Germany Paid F# development with SAFE Training Nov 7 2018 Vienna, Austria Lambda Factory Paid","title":"Events"},{"location":"events/#upcoming-events","text":"Title Type Date Location Who Cost","title":"Upcoming events"},{"location":"events/#past-events","text":"","title":"Past events"},{"location":"events/#2019","text":"Title Type Date Location Who Cost SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 22 2019 Dresden, Germany Compositional IT Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 23 2019 Prague, Czech Republic Compositional IT Free Web development with SAFE Stack Conference Jan 26 2019 Minsk, Belarus Mikhail Smal Paid Hacking F# in JS ecosystem Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free Reinventing MVC pattern for web programming with F# Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Feb 12 2019 Osnabr\u00fcck, Germany Compositional IT Free SAFE web development with F# User Group Mar 28 2019 Prague, Czech Republic Mikhail Smal Free SAFE Stack: Current State Conference April 4-5 2019 London, UK Tomasz Heimowski Paid Workshop: Up and Running with the SAFE Stack Conference April 4-5 2019 London, UK Compositional IT Paid The Pit of Success with SAFE Stack User Group April 11 2019 Berlin, Germany Isaac Abraham Free Workshop: Hands on with F# Conference workshop April 27 2019 Berlin, Germany Isaac Abraham Free Workshop: SAFE Web development with F# Conference May 14 2019 Vilnius, Lithuania Mikhail Smal Paid Write Your Own Domain Specific Language with F# Conference May 15-16 2019 Vilnius, Lithuania Mikhail Smal Paid Full Stack Web in F# Conference June 8 2019 Minsk, Belarus Tomasz Heimowski Paid Write Your Own Domain Specific Language with F# Conference Jun 18 2019 Oslo, Norway Mikhail Smal Paid FableConf Conference Sep 6-7 2019 Antwerp, Belgium Paid Functional Web Programming with the SAFE Stack Training Sep 12-13 2019 London, UK Isaac Abraham / Compositional IT Paid Hands-on with SAFE Stack Conference Oct 17-18 2019 C\u00e1diz, Spain Tomasz Heimowski Paid Full Stack Web in F# Conference November 6-8 2019 Malm\u00f6, Sweden Tomasz Heimowski Paid","title":"2019"},{"location":"events/#2018","text":"Title Type Date Location Who Cost SAFE apps with F# web stack Conference Feb 23 2018 Krak\u00f3w, Poland Tomasz Heimowski Paid SAFE apps with F# web stack Conference April 5 2018 London, UK Tomasz Heimowski Paid SAFE Stack Workshop User Group Aug 22 2018 Bristol, UK Compositional IT Free SAFE apps with F# web stack Conference Sep 21 2018 Gda\u0144sk, Poland Tomasz Heimowski Free SAFE Stack: Functional Web Programming in .NET Conference Sep 22 2018 Cambridge, UK Compositional IT Free F# Full Stack with SAFE Training Sep 26 2018 San Francisco, USA Lambda Factory Paid SAFE Hackday Training Oct 6 2018 Birmingham, UK Ian Russel Free Cloud Programming with F# Training Oct 25 2018 Berlin, Germany Compositional IT Paid FableConf / RemmiDemmi Conference Oct 26/27 2018 Berlin, Germany Paid F# development with SAFE Training Nov 7 2018 Vienna, Austria Lambda Factory Paid","title":"2018"},{"location":"faq-build/","text":"Support for moving from development to production with SAFE applications is included \"out of the box\" when using e.g. Azure or Docker deployment options. Nonetheless, this page explains the key differences that you should be aware of between running SAFE applications in development and production. Developing SAFE applications The SAFE template is geared up towards a streamlined development process. Firstly, it contains a FAKE build script which you can use this to quickly download dependencies, as well as build and run both the client and server on your machine. The development process uses two web servers running in tandem: The \"back-end\" .NET web server which hosts your API endpoints and other server-generated content. This uses Kestrel on ASP .NET out of the box (although you can opt for other options ). A \"front-end\" web server which hosts your Fable application. The SAFE template uses the Webpack Dev Server for this. The backend build makes use of dotnet watch to allow you to make changes to your server-side application and have the server automatically restart with the latest changes. Since your back-end applications will typically be stateless, this permits a rapid development workflow. On the client side, your code is compiled using webpack. This provides many benefits for working with javascript, such as minification and bundling, as well as hot module replacement , a feature made possible when using the webpack dev server. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application. Webpack Dev Server It's important to note that the webpack dev server is configured to automatically route traffic intended for api/* routes to the back-end web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues. You can find out more about the configuration of the webpack dev server in SAFE here . Running SAFE applications in production In a production environment, you won't typically use the webpack dev server. Instead, it's more common to use webpack as a one-off compiler step to create your bundled javascript from your Fable app (plus dependencies), and then deploy this along with your back-end web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your back-end APIs. This fits very well with standard CI / CD processes, as a build step in your FAKE script or VSTS / AppVeyor / Travis step etc. All deployments options do this automatically. Client asset hosting alternatives Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.","title":"Moving from dev to prod"},{"location":"faq-build/#developing-safe-applications","text":"The SAFE template is geared up towards a streamlined development process. Firstly, it contains a FAKE build script which you can use this to quickly download dependencies, as well as build and run both the client and server on your machine. The development process uses two web servers running in tandem: The \"back-end\" .NET web server which hosts your API endpoints and other server-generated content. This uses Kestrel on ASP .NET out of the box (although you can opt for other options ). A \"front-end\" web server which hosts your Fable application. The SAFE template uses the Webpack Dev Server for this. The backend build makes use of dotnet watch to allow you to make changes to your server-side application and have the server automatically restart with the latest changes. Since your back-end applications will typically be stateless, this permits a rapid development workflow. On the client side, your code is compiled using webpack. This provides many benefits for working with javascript, such as minification and bundling, as well as hot module replacement , a feature made possible when using the webpack dev server. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application.","title":"Developing SAFE applications"},{"location":"faq-build/#webpack-dev-server","text":"It's important to note that the webpack dev server is configured to automatically route traffic intended for api/* routes to the back-end web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues. You can find out more about the configuration of the webpack dev server in SAFE here .","title":"Webpack Dev Server"},{"location":"faq-build/#running-safe-applications-in-production","text":"In a production environment, you won't typically use the webpack dev server. Instead, it's more common to use webpack as a one-off compiler step to create your bundled javascript from your Fable app (plus dependencies), and then deploy this along with your back-end web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your back-end APIs. This fits very well with standard CI / CD processes, as a build step in your FAKE script or VSTS / AppVeyor / Travis step etc. All deployments options do this automatically.","title":"Running SAFE applications in production"},{"location":"faq-build/#client-asset-hosting-alternatives","text":"Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.","title":"Client asset hosting alternatives"},{"location":"faq-server/","text":"Server-side options in SAFE The SAFE template comes with two alternative web server technologies out of the box: Saturn - A simple, flexible F# abstraction layer that runs on top of Giraffe that enables both MVC- and Web API-style services. Giraffe - A flexible F# framework for creating web-enabled applications. Giraffe runs on top of ASP .NET Core and the Kestrel server. Both Saturn and Giraffe are fully ASP .NET Core compatible and offer F#-first programming experiences - there's no need to wrap your DTOs in [<CLIMutable>] or inherit from base classes to get up and running. Why Saturn? Saturn is the default and recommended web server in SAFE . Saturn (and Giraffe) runs on top of ASP .NET Core, which comes with an extremely high-performance server that is fully supported by Microsoft, has a huge community of developers and has excellent integration into cloud services such as Microsoft Azure and Amazon Web Services. In addition, whilst the Giraffe programming is extremely composable and fully functional-first, Saturn allows you to take advantage of abstractions such as application { } , scope { } and controller { } which are not only extremely simple to use but will also be familiar to developers from other (non-.NET) web programming models. It's important to note that Saturn lives \"on top\" of Giraffe; you can think of Saturn as a layer of added goodness which provide a set of new higher-level abstractions which delegate down to Giraffe's HTTP Handler. And since Saturn's abstractions are all optional , you can always fall back directly to the lower-level Giraffe model if required. Coming from Suave? Giraffe's HTTP Handler is a very similar abstraction to that of the Suave web server, which means that you can easily migrate over to Giraffe (and Saturn) and quickly start to benefit from the features that ASP .NET, Giraffe and Saturn all provide.","title":"Choosing your web server"},{"location":"faq-server/#server-side-options-in-safe","text":"The SAFE template comes with two alternative web server technologies out of the box: Saturn - A simple, flexible F# abstraction layer that runs on top of Giraffe that enables both MVC- and Web API-style services. Giraffe - A flexible F# framework for creating web-enabled applications. Giraffe runs on top of ASP .NET Core and the Kestrel server. Both Saturn and Giraffe are fully ASP .NET Core compatible and offer F#-first programming experiences - there's no need to wrap your DTOs in [<CLIMutable>] or inherit from base classes to get up and running.","title":"Server-side options in SAFE"},{"location":"faq-server/#why-saturn","text":"Saturn is the default and recommended web server in SAFE . Saturn (and Giraffe) runs on top of ASP .NET Core, which comes with an extremely high-performance server that is fully supported by Microsoft, has a huge community of developers and has excellent integration into cloud services such as Microsoft Azure and Amazon Web Services. In addition, whilst the Giraffe programming is extremely composable and fully functional-first, Saturn allows you to take advantage of abstractions such as application { } , scope { } and controller { } which are not only extremely simple to use but will also be familiar to developers from other (non-.NET) web programming models. It's important to note that Saturn lives \"on top\" of Giraffe; you can think of Saturn as a layer of added goodness which provide a set of new higher-level abstractions which delegate down to Giraffe's HTTP Handler. And since Saturn's abstractions are all optional , you can always fall back directly to the lower-level Giraffe model if required.","title":"Why Saturn?"},{"location":"faq-server/#coming-from-suave","text":"Giraffe's HTTP Handler is a very similar abstraction to that of the Suave web server, which means that you can easily migrate over to Giraffe (and Saturn) and quickly start to benefit from the features that ASP .NET, Giraffe and Saturn all provide.","title":"Coming from Suave?"},{"location":"faq-troubleshooting/","text":"Getting Started FAKE cannot be found If you fail to execute fake from command line after installing it as a global tool, you might need to add it to your PATH manually: (e.g. export PATH=\"$HOME/.dotnet/tools:$PATH\" on unix) - related GitHub issue Diagnostics SocketProtocolError in Debug Console You may see the following SocketProtocolError message in the Debug Console once you have started your SAFE application. WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404 Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section. Debugging in VS Code Node Process does not stop after stopping the debugger VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for Watch Client task. Tracked here . Chrome opens to a blank window Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts. Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised. Fable JavaScript bundle size A project created from SAFE template might issue following warning from Webpack upon building the JavaScript bundle: WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit. To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills. For more info, see this issue .","title":"Troubleshooting"},{"location":"faq-troubleshooting/#getting-started","text":"","title":"Getting Started"},{"location":"faq-troubleshooting/#fake-cannot-be-found","text":"If you fail to execute fake from command line after installing it as a global tool, you might need to add it to your PATH manually: (e.g. export PATH=\"$HOME/.dotnet/tools:$PATH\" on unix) - related GitHub issue","title":"FAKE cannot be found"},{"location":"faq-troubleshooting/#diagnostics","text":"","title":"Diagnostics"},{"location":"faq-troubleshooting/#socketprotocolerror-in-debug-console","text":"You may see the following SocketProtocolError message in the Debug Console once you have started your SAFE application. WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404 Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section.","title":"SocketProtocolError in Debug Console"},{"location":"faq-troubleshooting/#debugging-in-vs-code","text":"","title":"Debugging in VS Code"},{"location":"faq-troubleshooting/#node-process-does-not-stop-after-stopping-the-debugger","text":"VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for Watch Client task. Tracked here .","title":"Node Process does not stop after stopping the debugger"},{"location":"faq-troubleshooting/#chrome-opens-to-a-blank-window","text":"Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts. Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised.","title":"Chrome opens to a blank window"},{"location":"faq-troubleshooting/#fable","text":"","title":"Fable"},{"location":"faq-troubleshooting/#javascript-bundle-size","text":"A project created from SAFE template might issue following warning from Webpack upon building the JavaScript bundle: WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit. To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills. For more info, see this issue .","title":"JavaScript bundle size"},{"location":"feature-azurefunctions/","text":"Going serverless with SAFE With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions . With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provides a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code. Potential use cases For SAFE apps we see various use cases for FAAS: Running recurring jobs to create statistics or maintenance actions via timer triggers Running jobs that can be processed async like creating accountings or sending email Command processing in CQRS apps via message queues or HTTP triggers Editing Functions in the Azure Portal The Azure Portal allows you to create and edit Functions and their source code via an online editor. For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language. Replace the contents of function.json with: { \"bindings\": [ { \"name\": \"myTimer\", \"type\": \"timerTrigger\", \"direction\": \"in\", \"schedule\": \"0 * * * * *\" } ], \"disabled\": false } and replace the run.fsx with the following F# code: open System let minutesSince (d: DateTime) = (DateTime.Now - d).TotalMinutes let run(myTimer: TimerInfo, log: TraceWriter) = let meetupStart = new DateTime(2017, 11, 8, 19, 0, 0) minutesSince meetupStart |> int |> sprintf \"Our meetup has been running for %d minutes\" |> log.Info Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration. While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below. Deployment In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure. Azure Functions Core Tools In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script: dotnet publish -c Release func azure functionapp publish [FunctionApp Name] This will compile your Function App in release mode and push it to the Azure portal. In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs). HTTPS Upload Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app. As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).","title":"Working with Azure functions"},{"location":"feature-azurefunctions/#going-serverless-with-safe","text":"With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions . With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provides a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code.","title":"Going serverless with SAFE"},{"location":"feature-azurefunctions/#potential-use-cases","text":"For SAFE apps we see various use cases for FAAS: Running recurring jobs to create statistics or maintenance actions via timer triggers Running jobs that can be processed async like creating accountings or sending email Command processing in CQRS apps via message queues or HTTP triggers","title":"Potential use cases"},{"location":"feature-azurefunctions/#editing-functions-in-the-azure-portal","text":"The Azure Portal allows you to create and edit Functions and their source code via an online editor. For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language. Replace the contents of function.json with: { \"bindings\": [ { \"name\": \"myTimer\", \"type\": \"timerTrigger\", \"direction\": \"in\", \"schedule\": \"0 * * * * *\" } ], \"disabled\": false } and replace the run.fsx with the following F# code: open System let minutesSince (d: DateTime) = (DateTime.Now - d).TotalMinutes let run(myTimer: TimerInfo, log: TraceWriter) = let meetupStart = new DateTime(2017, 11, 8, 19, 0, 0) minutesSince meetupStart |> int |> sprintf \"Our meetup has been running for %d minutes\" |> log.Info Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration. While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below.","title":"Editing Functions in the Azure Portal"},{"location":"feature-azurefunctions/#deployment","text":"In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure.","title":"Deployment"},{"location":"feature-azurefunctions/#azure-functions-core-tools","text":"In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script: dotnet publish -c Release func azure functionapp publish [FunctionApp Name] This will compile your Function App in release mode and push it to the Azure portal. In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs).","title":"Azure Functions Core Tools"},{"location":"feature-azurefunctions/#https-upload","text":"Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app. As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).","title":"HTTPS Upload"},{"location":"feature-clientserver-basics/","text":"Sharing Types Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g Shared.fs . Then, create types in the file as needed e.g type Customer = { Id : int; Name : string } Reference this file to your server project. You can now reference those types in the server. <Project Sdk=\"Microsoft.NET.Sdk\"> ... <ItemGroup> <Compile Include=\"../Shared/Shared.fs\" /> </ItemGroup> ... </Project> Finally, reference this file to your client project (as above). You can now reference those types in the client; Fable will automatically convert your F# types into Javascript in the background. Sharing Behaviour You can also share code using the same mechanism as sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server. Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including: ASP.NET Core (via Saturn) Azure Functions Javascript that runs in the browser Javascript that runs on mobile devices with React Native . Raspberry Pi (via .NET Core) You can read more about this on the Fable website .","title":"Sharing Types and Code"},{"location":"feature-clientserver-basics/#sharing-types","text":"Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g Shared.fs . Then, create types in the file as needed e.g type Customer = { Id : int; Name : string } Reference this file to your server project. You can now reference those types in the server. <Project Sdk=\"Microsoft.NET.Sdk\"> ... <ItemGroup> <Compile Include=\"../Shared/Shared.fs\" /> </ItemGroup> ... </Project> Finally, reference this file to your client project (as above). You can now reference those types in the client; Fable will automatically convert your F# types into Javascript in the background.","title":"Sharing Types"},{"location":"feature-clientserver-basics/#sharing-behaviour","text":"You can also share code using the same mechanism as sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server. Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including: ASP.NET Core (via Saturn) Azure Functions Javascript that runs in the browser Javascript that runs on mobile devices with React Native . Raspberry Pi (via .NET Core) You can read more about this on the Fable website .","title":"Sharing Behaviour"},{"location":"feature-clientserver-bridge/","text":"Using F# on both client and server is at the core of the SAFE stack, as it simplifies the way we think about building web applications by using the same language, idioms and in many cases sharing our code and domain models. However, building a client and a server app requires a fundamentally different way of thinking. On the server side we build stateless APIs in Saturn that map HTTP requests to internal functionality, whereas on the frontend we use the Elmish model, implementing the model-view-update pattern : a stateful pattern that lets us think about the application state as it evolves while the application running. Even though we use the same language across platforms, applying these two different programming models forces us to switch our way of thinking back and forth when writing code for the client and for the server. This is where the Elmish.Bridge library comes into play: it brings the Elmish programming model to the server and unifies the way we write the application as a whole. How does Elmish work on the server? Think of Elmish on the server as the model-view-update pattern but without the view part . Instead, you only need to implement init and update functions to manage the server state as it evolves while the server is running. Server state can contain data that is relevant to a single or all clients The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection The update functions on client and server can exchange data via message passing. A simple example Let's see a simple example of how this might work in practice: // Client-side let update msg state = match msg with | LoadUsers -> // send the message to the server state, Cmd.bridgeSend ServerMsg.LoadUsers | UsersLoaded users -> // receive message from the server let nextState = { state with Users = users } nextState, Cmd.none // Server-side let update clientDispatch msg state = match msg with | ServerMsg.LoadUsers -> let loadUsersCmd = Cmd.ofAsync getUsersFromDb // unit -> Async<User list> () // input arg = unit UsersLoadedFromDb // User list -> ServerMsg DoNothing // ServerMsg state, loadUsersCmd | ServerMsg.UsersLoadedFromDbSuccess users -> // answer the current connected client with data clientDispatch (ClientMsg.UsersLoaded users) state, Cmd.none | ServerMsg.DoNothing -> state, Cmd.none The above example mimics what would have been a GET request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users. When to use Elmish.Bridge There are many scenarios where it makes sense to use Elmish.Bridge: Chat-like applications with many connected users through many channels Syncing price data in real-time while viewing ticket prices Multiplayer games that need real-time update of game states Other applications of web sockets through an Elmish model Things to consider The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design. The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset. The server state is local to the server instance . This means that if you run multiple web servers, they won't be sharing the same server state by default. As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc. In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients. Learn more about Elmish.Bridge Head over to Elmish.Bridge to learn more.","title":"Stateful Messaging through Bridge"},{"location":"feature-clientserver-bridge/#how-does-elmish-work-on-the-server","text":"Think of Elmish on the server as the model-view-update pattern but without the view part . Instead, you only need to implement init and update functions to manage the server state as it evolves while the server is running. Server state can contain data that is relevant to a single or all clients The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection The update functions on client and server can exchange data via message passing.","title":"How does Elmish work on the server?"},{"location":"feature-clientserver-bridge/#a-simple-example","text":"Let's see a simple example of how this might work in practice: // Client-side let update msg state = match msg with | LoadUsers -> // send the message to the server state, Cmd.bridgeSend ServerMsg.LoadUsers | UsersLoaded users -> // receive message from the server let nextState = { state with Users = users } nextState, Cmd.none // Server-side let update clientDispatch msg state = match msg with | ServerMsg.LoadUsers -> let loadUsersCmd = Cmd.ofAsync getUsersFromDb // unit -> Async<User list> () // input arg = unit UsersLoadedFromDb // User list -> ServerMsg DoNothing // ServerMsg state, loadUsersCmd | ServerMsg.UsersLoadedFromDbSuccess users -> // answer the current connected client with data clientDispatch (ClientMsg.UsersLoaded users) state, Cmd.none | ServerMsg.DoNothing -> state, Cmd.none The above example mimics what would have been a GET request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users.","title":"A simple example"},{"location":"feature-clientserver-bridge/#when-to-use-elmishbridge","text":"There are many scenarios where it makes sense to use Elmish.Bridge: Chat-like applications with many connected users through many channels Syncing price data in real-time while viewing ticket prices Multiplayer games that need real-time update of game states Other applications of web sockets through an Elmish model","title":"When to use Elmish.Bridge"},{"location":"feature-clientserver-bridge/#things-to-consider","text":"The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design. The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset. The server state is local to the server instance . This means that if you run multiple web servers, they won't be sharing the same server state by default. As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc. In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients.","title":"Things to consider"},{"location":"feature-clientserver-bridge/#learn-more-about-elmishbridge","text":"Head over to Elmish.Bridge to learn more.","title":"Learn more about Elmish.Bridge"},{"location":"feature-clientserver-http/","text":"Client Server communication over HTTP Communicating over raw HTTP using Saturn has three main steps. 1. Load your data Start by creating a function in your server that returns some data: let loadCustomersFromDb() = [ { Id = 1; Name = \"Joe Bloggs\" } ] Next, create a method which returns the data as JSON within Giraffe's HTTP context. /// Returns the results of loadCustomersFromDb as JSON. let getCustomers next ctx = json (loadCustomersFromDb()) next ctx You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints. Also note the next and ctx arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the json function (Note you can also use Successful.Ok instead of json , which will offer XML serialization as well). 2. Expose data through Saturn Now expose the api method using Saturn's router construct and add it to your overall application scope: let myApis = router { get \"/api/customers/\" getCustomers } For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the next and ctx arguments): let myApis = router { get \"/api/customers/\" (json (loadCustomersFromDb())) } 3. Consume the endpoint from the client Finally, call the endpoint from your client application. promise { let! customers = Fetch.fetchAs<Customer list> \"api/customers\" (Decode.Auto.generateDecoder()) [] // do more with customers here... } Note the use of the promise { } computation expression. This behaves similarly to async { } blocks that you might already know, whilst the fetchAs function retrieves data from the HTTP endpoint specified. The JSON is deserialized a Customer array using an automatically-generated \"decoder\" (see the section on serialization for more information).","title":"Messaging using HTTP"},{"location":"feature-clientserver-http/#client-server-communication-over-http","text":"Communicating over raw HTTP using Saturn has three main steps.","title":"Client Server communication over HTTP"},{"location":"feature-clientserver-http/#1-load-your-data","text":"Start by creating a function in your server that returns some data: let loadCustomersFromDb() = [ { Id = 1; Name = \"Joe Bloggs\" } ] Next, create a method which returns the data as JSON within Giraffe's HTTP context. /// Returns the results of loadCustomersFromDb as JSON. let getCustomers next ctx = json (loadCustomersFromDb()) next ctx You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints. Also note the next and ctx arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the json function (Note you can also use Successful.Ok instead of json , which will offer XML serialization as well).","title":"1. Load your data"},{"location":"feature-clientserver-http/#2-expose-data-through-saturn","text":"Now expose the api method using Saturn's router construct and add it to your overall application scope: let myApis = router { get \"/api/customers/\" getCustomers } For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the next and ctx arguments): let myApis = router { get \"/api/customers/\" (json (loadCustomersFromDb())) }","title":"2. Expose data through Saturn"},{"location":"feature-clientserver-http/#3-consume-the-endpoint-from-the-client","text":"Finally, call the endpoint from your client application. promise { let! customers = Fetch.fetchAs<Customer list> \"api/customers\" (Decode.Auto.generateDecoder()) [] // do more with customers here... } Note the use of the promise { } computation expression. This behaves similarly to async { } blocks that you might already know, whilst the fetchAs function retrieves data from the HTTP endpoint specified. The JSON is deserialized a Customer array using an automatically-generated \"decoder\" (see the section on serialization for more information).","title":"3. Consume the endpoint from the client"},{"location":"feature-clientserver-remoting/","text":"Data sharing with Fable.Remoting Alongside raw HTTP, you can also use Fable.Remoting , which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract . 1. Define a protocol Each field of the record is either of type Async<T> or a function that returns Async<T> , for example: type ICustomerApi = { getCustomers : unit -> Async<Customer list> findCustomerByName : string -> Async<Customer option> } The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discrimincated unions or collections etc. 2. Implement the protocol on the server On the server you would implement the protocol as follows: let getCustomers() = async { return [ { Id = 1; Name = \"John Doe\" } { Id = 2; Name = \"Jane Smith\" } ] } let findCustomerByName (name: string) = async { let! allCustomers = getCustomers() return allCustomers |> List.tryFind (fun c -> c.Name = name) } let customerApi : ICustomerApi = { getCustomers = getCustomers findCustomerByName = findCustomerByName } 3. Consume the protocol on the client After exposing an HttpHandler from customerApi you can start calling the API from the client. let api = Remoting.createApi() |> Remoting.buildProxy<ICustomerApi> async { let! customers = api.getCustomers() for customer in customers do printfn \"#%d => %s\" customer.Id customer.Name } Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes.","title":"Messaging with Protocols"},{"location":"feature-clientserver-remoting/#data-sharing-with-fableremoting","text":"Alongside raw HTTP, you can also use Fable.Remoting , which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract .","title":"Data sharing with Fable.Remoting"},{"location":"feature-clientserver-remoting/#1-define-a-protocol","text":"Each field of the record is either of type Async<T> or a function that returns Async<T> , for example: type ICustomerApi = { getCustomers : unit -> Async<Customer list> findCustomerByName : string -> Async<Customer option> } The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discrimincated unions or collections etc.","title":"1. Define a protocol"},{"location":"feature-clientserver-remoting/#2-implement-the-protocol-on-the-server","text":"On the server you would implement the protocol as follows: let getCustomers() = async { return [ { Id = 1; Name = \"John Doe\" } { Id = 2; Name = \"Jane Smith\" } ] } let findCustomerByName (name: string) = async { let! allCustomers = getCustomers() return allCustomers |> List.tryFind (fun c -> c.Name = name) } let customerApi : ICustomerApi = { getCustomers = getCustomers findCustomerByName = findCustomerByName }","title":"2. Implement the protocol on the server"},{"location":"feature-clientserver-remoting/#3-consume-the-protocol-on-the-client","text":"After exposing an HttpHandler from customerApi you can start calling the API from the client. let api = Remoting.createApi() |> Remoting.buildProxy<ICustomerApi> async { let! customers = api.getCustomers() for customer in customers do printfn \"#%d => %s\" customer.Id customer.Name } Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes.","title":"3. Consume the protocol on the client"},{"location":"feature-clientserver-serialization/","text":"Serialization basics with Thoth When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types. In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together. let configureSerialization (services:IServiceCollection) = services.AddSingleton<Giraffe.Serialization.Json.IJsonSerializer>(Thoth.Json.Giraffe.ThothSerializer()) If you are using the SAFE Template , this will automatically be done for you in Server.fs . Approaches to deserialization Fable 2 uses the Thoth library for JSON deserialization, which makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders. Assume the following Customer record for the remaining examples. type Customer = { Id : int Name : string } Automatic Decoders Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the /api/customers endpoint and have Thoth create a strongly-typed Decoder for a Customer array. fetchAs<Customer []> \"/api/customers\" (Decode.Auto.generateDecoder()) [] If the serialization fails, Thoth will create an Error (rather than Ok ) value for this. Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes. Improving efficiency with cached decoders You can reuse decoders when you know you'll be calling them often: // let-bound value that exists outside of the update function let customerDecoder = Decode.Auto.generateDecoder<Customer>() // inside the update function Fetch.fetchAs (sprintf \"api/customers\") (Decode.array customerDecoder []) Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example api/customers/1 which would return a single Customer object rather than a collection. Manual Decoders Manual decoders give you total control over how you rehydrate an object from JSON. Use them when: The JSON does not directly map 1:1 with your F# types You want flexibility to evolve JSON and F# types independently You are calling an external service and need fine-grained control over the deserialization process You are using F# on the client and another language on the server You create a manual decoder as follows: let customerDecoder : Decoder<Customer> = Decode.object (fun get -> { Id = get.Required.Field \"id\" Decode.int Name = get.Optional.Field \"customerName\" Decode.string |> Option.defaultValue \"\" }) You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows: Decode.fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\" If decoding fails on any field, an error case will be returned. Handling \"unit\" calls You may design API methods that return unit i.e. they have no result. In such a case, you must currently do one of the following: Return some non-unit type e.g. boolean or int etc. and simply ignore it on the client response. Set the result type on the client as obj (or even _ - the F# compiler will infer obj for you). This will be correctly handled by Thoth and passed as a null object which can be safely ignored.","title":"Serialization in SAFE"},{"location":"feature-clientserver-serialization/#serialization-basics-with-thoth","text":"When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types. In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together. let configureSerialization (services:IServiceCollection) = services.AddSingleton<Giraffe.Serialization.Json.IJsonSerializer>(Thoth.Json.Giraffe.ThothSerializer()) If you are using the SAFE Template , this will automatically be done for you in Server.fs .","title":"Serialization basics with Thoth"},{"location":"feature-clientserver-serialization/#approaches-to-deserialization","text":"Fable 2 uses the Thoth library for JSON deserialization, which makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders. Assume the following Customer record for the remaining examples. type Customer = { Id : int Name : string }","title":"Approaches to deserialization"},{"location":"feature-clientserver-serialization/#automatic-decoders","text":"Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the /api/customers endpoint and have Thoth create a strongly-typed Decoder for a Customer array. fetchAs<Customer []> \"/api/customers\" (Decode.Auto.generateDecoder()) [] If the serialization fails, Thoth will create an Error (rather than Ok ) value for this. Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes.","title":"Automatic Decoders"},{"location":"feature-clientserver-serialization/#improving-efficiency-with-cached-decoders","text":"You can reuse decoders when you know you'll be calling them often: // let-bound value that exists outside of the update function let customerDecoder = Decode.Auto.generateDecoder<Customer>() // inside the update function Fetch.fetchAs (sprintf \"api/customers\") (Decode.array customerDecoder []) Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example api/customers/1 which would return a single Customer object rather than a collection.","title":"Improving efficiency with cached decoders"},{"location":"feature-clientserver-serialization/#manual-decoders","text":"Manual decoders give you total control over how you rehydrate an object from JSON. Use them when: The JSON does not directly map 1:1 with your F# types You want flexibility to evolve JSON and F# types independently You are calling an external service and need fine-grained control over the deserialization process You are using F# on the client and another language on the server You create a manual decoder as follows: let customerDecoder : Decoder<Customer> = Decode.object (fun get -> { Id = get.Required.Field \"id\" Decode.int Name = get.Optional.Field \"customerName\" Decode.string |> Option.defaultValue \"\" }) You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows: Decode.fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\" If decoding fails on any field, an error case will be returned.","title":"Manual Decoders"},{"location":"feature-clientserver-serialization/#handling-unit-calls","text":"You may design API methods that return unit i.e. they have no result. In such a case, you must currently do one of the following: Return some non-unit type e.g. boolean or int etc. and simply ignore it on the client response. Set the result type on the client as obj (or even _ - the F# compiler will infer obj for you). This will be correctly handled by Thoth and passed as a null object which can be safely ignored.","title":"Handling \"unit\" calls"},{"location":"feature-clientserver/","text":"One of the most powerful features of SAFE is the ability to seamlessly share code across client and server. Sharing Basics The basics of code sharing across client and server include: Sharing types . Useful for contracts between client and server, as well as to share a common domain Sharing behaviour . In other words, functions that perform e.g. shared validation or similar. These two core areas are explained in more detail here . Sending messages between client and server In addition to types and messages, there are several technologies availabile in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses: Raw HTTP using Saturn's routing capabilities. Contracts / protocols via Fable Remoting. Stateful servers through Elmish Bridge. Which technology should I use? The raw HTTP model provided by Saturn with router { } requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach. Alternatively, Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. If you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting is probably not for you. Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients. Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No No Yes Pipeline Control? Limited Full Limited Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!","title":"Sharing Overview"},{"location":"feature-clientserver/#sharing-basics","text":"The basics of code sharing across client and server include: Sharing types . Useful for contracts between client and server, as well as to share a common domain Sharing behaviour . In other words, functions that perform e.g. shared validation or similar. These two core areas are explained in more detail here .","title":"Sharing Basics"},{"location":"feature-clientserver/#sending-messages-between-client-and-server","text":"In addition to types and messages, there are several technologies availabile in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses: Raw HTTP using Saturn's routing capabilities. Contracts / protocols via Fable Remoting. Stateful servers through Elmish Bridge.","title":"Sending messages between client and server"},{"location":"feature-clientserver/#which-technology-should-i-use","text":"The raw HTTP model provided by Saturn with router { } requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach. Alternatively, Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. If you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting is probably not for you. Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients. Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No No Yes Pipeline Control? Limited Full Limited Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!","title":"Which technology should I use?"},{"location":"feature-debugging/","text":"A powerful features of the SAFE Stack is that it supports combined client / server debugging in F#. This means that you can use a single IDE (in this case, Visual Studio Code ) to debug both client and server code in the same IDE session . As of v0.38 of the SAFE Template, new SAFE applications come pre-configured with build, launch and debugging support in VS Code. Prerequisites Install Google Chrome : Enables client-side debugging. Configure Chrome with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Launching and debugging a SAFE application in VS Code The SAFE template allows you to launch a SAFE Stack application with both client and server debugging enabled automatically. Create a new SAFE application using the SAFE template Open VS Code in the folder containing your application Go to the Debug pane ( CTRL + Shift + D ) Note : Depending on your configuration, the Debug pane may be pinned to the left- or right-hand-side of VS Code. Ensure that Debug SAFE App is selected as the launch configuration Hit F5 to launch the application, or hit the green play button in the launch configuration panel That's it. VS Code will now automatically: Download all dependencies for both client and server Build both the client and server Start both client and server Attach debuggers for both the client and server simultaneously! Note : When you stop debugging, you also need to kill the associated Watch Client task - see details . The VS Code debugger This section explains the basics of debugging SAFE applications with VS Code. Refer to here to learn more about the VS Code debugger. VS Code Tooling basics Once you start debugging a SAFE app, in the Terminal pane two Tasks will begin in parallel: Watch Client : Builds and runs the client in hot module reload mode Build Server : Builds and runs the server Low-level output from the command line of both client and server can be seen in the appropriate Terminal window. Observe that the floating Debug control contains two active debugging sessions: Debug Client : Selects the Client debug session Debug Server : Selects the Server debug session Selecting one or the other will instruct the Debug pane to show details for that \"side\" of the application e.g. breakpoints, call stack etc. Setting breakpoints To set a breakpoint, simply highlight the line of code that you wish to stop on and hit F9 , or click on the left-side gutter of the code window; a red dot will appear to show the breakpoint is set. You can see more on VS Code breakpoints here . Here you can see a breakpoint that has been hit in the update method of the sample application that is bundled with the SAFE template. Viewing debug output Debug output from Chrome will automatically be sent to the integrated Debug Console. This is especially useful for Elmish applications, as you can view Elmish messages and model updates directly in the IDE. Restarting your application In the standard launch mode seen above, hot module reloading is enabled on the client, so changes that are made to your Fable application will occur immediately. However, in order to support debugging, watch mode is not enabled on the server; server changes require a restart of the server debugging session: Having ensured that Debug Server is selected in the floating Debug control, select the Restart icon or hit CTRL + SHIFT + F5 . The server will stop, rebuild and restart with the debugger automatically re-attached. Advanced options The SAFE template comes with several other modes of operation for debugging: Full watch mode If you prefer to use \"watch\" mode on both client and server, choose the Watch SAFE app option from the Debug Launcher. Here, changes to any server file will automatically initiate a restart of it. However, whilst you will still be able to debug the client, in this mode there is no capability for server-side debugging. Debug Server or Client only You can also launch and debug either the client or server in isolation. This may be useful if you are running the other component separately e.g. through FAKE, the dotnet command line tool directly or via Visual Studio. You can initiate this by choosing either Debug Client or Debug Server as required. Build Server You can initiate a restore and rebuild of the server by hitting CTRL + SHIFT + B and selecting Build Server from the drop-down. Troubleshooting Still have issues getting the debugger to work? Check out the troubleshooting page.","title":"Full Stack Debugging"},{"location":"feature-debugging/#prerequisites","text":"Install Google Chrome : Enables client-side debugging. Configure Chrome with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code.","title":"Prerequisites"},{"location":"feature-debugging/#launching-and-debugging-a-safe-application-in-vs-code","text":"The SAFE template allows you to launch a SAFE Stack application with both client and server debugging enabled automatically. Create a new SAFE application using the SAFE template Open VS Code in the folder containing your application Go to the Debug pane ( CTRL + Shift + D ) Note : Depending on your configuration, the Debug pane may be pinned to the left- or right-hand-side of VS Code. Ensure that Debug SAFE App is selected as the launch configuration Hit F5 to launch the application, or hit the green play button in the launch configuration panel That's it. VS Code will now automatically: Download all dependencies for both client and server Build both the client and server Start both client and server Attach debuggers for both the client and server simultaneously! Note : When you stop debugging, you also need to kill the associated Watch Client task - see details .","title":"Launching and debugging a SAFE application in VS Code"},{"location":"feature-debugging/#the-vs-code-debugger","text":"This section explains the basics of debugging SAFE applications with VS Code. Refer to here to learn more about the VS Code debugger.","title":"The VS Code debugger"},{"location":"feature-debugging/#vs-code-tooling-basics","text":"Once you start debugging a SAFE app, in the Terminal pane two Tasks will begin in parallel: Watch Client : Builds and runs the client in hot module reload mode Build Server : Builds and runs the server Low-level output from the command line of both client and server can be seen in the appropriate Terminal window. Observe that the floating Debug control contains two active debugging sessions: Debug Client : Selects the Client debug session Debug Server : Selects the Server debug session Selecting one or the other will instruct the Debug pane to show details for that \"side\" of the application e.g. breakpoints, call stack etc.","title":"VS Code Tooling basics"},{"location":"feature-debugging/#setting-breakpoints","text":"To set a breakpoint, simply highlight the line of code that you wish to stop on and hit F9 , or click on the left-side gutter of the code window; a red dot will appear to show the breakpoint is set. You can see more on VS Code breakpoints here . Here you can see a breakpoint that has been hit in the update method of the sample application that is bundled with the SAFE template.","title":"Setting breakpoints"},{"location":"feature-debugging/#viewing-debug-output","text":"Debug output from Chrome will automatically be sent to the integrated Debug Console. This is especially useful for Elmish applications, as you can view Elmish messages and model updates directly in the IDE.","title":"Viewing debug output"},{"location":"feature-debugging/#restarting-your-application","text":"In the standard launch mode seen above, hot module reloading is enabled on the client, so changes that are made to your Fable application will occur immediately. However, in order to support debugging, watch mode is not enabled on the server; server changes require a restart of the server debugging session: Having ensured that Debug Server is selected in the floating Debug control, select the Restart icon or hit CTRL + SHIFT + F5 . The server will stop, rebuild and restart with the debugger automatically re-attached.","title":"Restarting your application"},{"location":"feature-debugging/#advanced-options","text":"The SAFE template comes with several other modes of operation for debugging:","title":"Advanced options"},{"location":"feature-debugging/#full-watch-mode","text":"If you prefer to use \"watch\" mode on both client and server, choose the Watch SAFE app option from the Debug Launcher. Here, changes to any server file will automatically initiate a restart of it. However, whilst you will still be able to debug the client, in this mode there is no capability for server-side debugging.","title":"Full watch mode"},{"location":"feature-debugging/#debug-server-or-client-only","text":"You can also launch and debug either the client or server in isolation. This may be useful if you are running the other component separately e.g. through FAKE, the dotnet command line tool directly or via Visual Studio. You can initiate this by choosing either Debug Client or Debug Server as required.","title":"Debug Server or Client only"},{"location":"feature-debugging/#build-server","text":"You can initiate a restore and rebuild of the server by hitting CTRL + SHIFT + B and selecting Build Server from the drop-down.","title":"Build Server"},{"location":"feature-debugging/#troubleshooting","text":"Still have issues getting the debugger to work? Check out the troubleshooting page.","title":"Troubleshooting"},{"location":"feature-hmr/","text":"Hot Module Replacement (HMR) allows to update the UI of an application while it is running, without a full reload. In SAFE stack apps, this can dramatically speed up the development for web and mobile GUIs, since there is no need to \"stop\" and \"reload\" and application. Instead, you can make changes to your views and have them immediately update in the browser, without the need to restart the application. How does it work? In case of web development, the webpack development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native 's own bundler. Why does it work so well with SAFE? Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case. Further reading Hot Module Replacement via webpack Introducing Hot Reloading in React Native","title":"Hot Module Replacement"},{"location":"feature-hmr/#how-does-it-work","text":"In case of web development, the webpack development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native 's own bundler.","title":"How does it work?"},{"location":"feature-hmr/#why-does-it-work-so-well-with-safe","text":"Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.","title":"Why does it work so well with SAFE?"},{"location":"feature-hmr/#further-reading","text":"Hot Module Replacement via webpack Introducing Hot Reloading in React Native","title":"Further reading"},{"location":"feature-ssr/","text":"Server-Side Rendering (SSR) means that some parts of your application code can run on both the server and the client. For React this means that you can render your components directly to HTML on the server side (e.g. via a node.js server ), which allows for better search engine optimization (SEO) and gives a faster initial response, especially on mobile devices. The browser typically receives a static HTML site and starts updating the UI immediately; React's bundle code will be downloaded asynchronously and when it completes, the client-side JavaScript will take over via React's hydrate functionality. In the JavaScript ecosystem this is also known as an \"isomorphic\" or \"universal\" app. Why use SSR? Pros Better SEO support, as web crawlers will directly see the fully rendered HTML page. Faster time-to-content, especially on slow internet connections or devices. Cons Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server. Increased complexity of build and deployment processes. Increased server-side load. SSR on SAFE In SAFE, SSR can be done using fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime. Further reading More details can be found in the SSR tutorial . The SAFE-BookStore sample project uses SSR.","title":"Server Side Rendering"},{"location":"feature-ssr/#why-use-ssr","text":"","title":"Why use SSR?"},{"location":"feature-ssr/#pros","text":"Better SEO support, as web crawlers will directly see the fully rendered HTML page. Faster time-to-content, especially on slow internet connections or devices.","title":"Pros"},{"location":"feature-ssr/#cons","text":"Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server. Increased complexity of build and deployment processes. Increased server-side load.","title":"Cons"},{"location":"feature-ssr/#ssr-on-safe","text":"In SAFE, SSR can be done using fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime.","title":"SSR on SAFE"},{"location":"feature-ssr/#further-reading","text":"More details can be found in the SSR tutorial . The SAFE-BookStore sample project uses SSR.","title":"Further reading"},{"location":"intro/","text":"What is SAFE? The SAFE stack is an open-source, free, flexible end-to-end, functional-first stack for cloud-ready web applications that emphasizes type-safe programming . The SAFE stack allows you to develop web applications almost entirely in F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. The SAFE stack is made up of four components: A web server running on .NET Core for hosting back-end services in F# A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers A mechanism to run F# in the web browser for client-side delivery of F# An F# programming model for client-side user interfaces Why SAFE? SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\". Create client / server applications entirely in F# Re-use development skills on client and server Rapidly create rich client-side web applications with no Javascript knowledge Runs on the latest .NET Core (and tested daily by Microsoft) Rapid development cycle with support for hot module replacement Interact with native Javascript libraries whenever needed Create client-side applications purely in F#, with full type checking for safety Seamlessly share code between client and server","title":"Introduction"},{"location":"intro/#what-is-safe","text":"The SAFE stack is an open-source, free, flexible end-to-end, functional-first stack for cloud-ready web applications that emphasizes type-safe programming . The SAFE stack allows you to develop web applications almost entirely in F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. The SAFE stack is made up of four components: A web server running on .NET Core for hosting back-end services in F# A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers A mechanism to run F# in the web browser for client-side delivery of F# An F# programming model for client-side user interfaces","title":"What is SAFE?"},{"location":"intro/#why-safe","text":"SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\". Create client / server applications entirely in F# Re-use development skills on client and server Rapidly create rich client-side web applications with no Javascript knowledge Runs on the latest .NET Core (and tested daily by Microsoft) Rapid development cycle with support for hot module replacement Interact with native Javascript libraries whenever needed Create client-side applications purely in F#, with full type checking for safety Seamlessly share code between client and server","title":"Why SAFE?"},{"location":"learning/","text":"This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace. Tutorials SAFE Dojo This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations. The dojo takes around 90 minutes to complete if you have never worked with the stack before. SAFE Samples The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page. SAFE Todo List The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two. tabula-rasa A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more. SAFE Bookstore This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store. SAFE ConfPlanner This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture. SAFE Search This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways. SAFE Chat This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library. SAFE Nightwatch This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you. Videos SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski) Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann) Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak) Other Resources The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps Learning about the F# SAFE stack High level introduction to the SAFE stack by Scott Hanselman","title":"Learning Resources"},{"location":"learning/#tutorials","text":"","title":"Tutorials"},{"location":"learning/#safe-dojo","text":"This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations. The dojo takes around 90 minutes to complete if you have never worked with the stack before.","title":"SAFE Dojo"},{"location":"learning/#safe-samples","text":"The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page.","title":"SAFE Samples"},{"location":"learning/#safe-todo-list","text":"The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two.","title":"SAFE Todo List"},{"location":"learning/#tabula-rasa","text":"A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more.","title":"tabula-rasa"},{"location":"learning/#safe-bookstore","text":"This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.","title":"SAFE Bookstore"},{"location":"learning/#safe-confplanner","text":"This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.","title":"SAFE ConfPlanner"},{"location":"learning/#safe-search","text":"This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.","title":"SAFE Search"},{"location":"learning/#safe-chat","text":"This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library.","title":"SAFE Chat"},{"location":"learning/#safe-nightwatch","text":"This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.","title":"SAFE Nightwatch"},{"location":"learning/#videos","text":"SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski) Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann) Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak)","title":"Videos"},{"location":"learning/#other-resources","text":"The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps Learning about the F# SAFE stack High level introduction to the SAFE stack by Scott Hanselman","title":"Other Resources"},{"location":"news/","text":"News and Announcements 2018 5th August We're pleased to see that the Suave team have clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project , and our server-side focus remains on improving the experience for both Giraffe and Saturn. We nonetheless wish the Suave project, team and contributors the best of luck for the future. 18th June Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team have today made the unamimous decision to remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling. Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP .NET. SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.","title":"News"},{"location":"news/#news-and-announcements","text":"","title":"News and Announcements"},{"location":"news/#2018","text":"","title":"2018"},{"location":"news/#5th-august","text":"We're pleased to see that the Suave team have clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project , and our server-side focus remains on improving the experience for both Giraffe and Saturn. We nonetheless wish the Suave project, team and contributors the best of luck for the future.","title":"5th August"},{"location":"news/#18th-june","text":"Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team have today made the unamimous decision to remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling. Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP .NET. SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.","title":"18th June"},{"location":"overview/","text":"SAFE Stack components The SAFE acronym is made up of four separate components: S aturn for back-end services in F# A zure as a hosting platform plus associated platform services F able for running F# in the web browser E lmish for client-side user interfaces Saturn The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP .NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve. Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model. Microsoft Azure Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions. Fable Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed. Elmish The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework. Further reading Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE. Are there alternative components in the SAFE stack? Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs: Giraffe is a programming model designed for F# that runs on ASP .NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe. Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core. AWS is Amazon's cloud compute offering, providing a large number of services available globally. WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.","title":"SAFE Stack Overview"},{"location":"overview/#safe-stack-components","text":"The SAFE acronym is made up of four separate components: S aturn for back-end services in F# A zure as a hosting platform plus associated platform services F able for running F# in the web browser E lmish for client-side user interfaces","title":"SAFE Stack components"},{"location":"overview/#saturn","text":"The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP .NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve. Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.","title":"Saturn"},{"location":"overview/#microsoft-azure","text":"Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.","title":"Microsoft Azure"},{"location":"overview/#fable","text":"Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.","title":"Fable"},{"location":"overview/#elmish","text":"The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework.","title":"Elmish"},{"location":"overview/#further-reading","text":"Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE.","title":"Further reading"},{"location":"overview/#are-there-alternative-components-in-the-safe-stack","text":"Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs: Giraffe is a programming model designed for F# that runs on ASP .NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe. Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core. AWS is Amazon's cloud compute offering, providing a large number of services available globally. WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.","title":"Are there alternative components in the SAFE stack?"},{"location":"quickstart/","text":"This page provides some basic guidance on getting up and running with your first SAFE application. Install pre-requisites You'll need to install the following pre-requisites in order to build SAFE applications The .NET Core SDK 3.0 FAKE (>= 5.12) installed as global tool ( dotnet tool install -g fake-cli ) Paket installed as global tool ( dotnet tool install paket --add-source https://www.myget.org/F/paket-netcore-as-tool/api/v3/index.json -g ) (optional*) node.js (>= 8.0) yarn (>= 1.10.1**) or npm * You don't need Paket if you just want to try out SAFE. However if you need to edit NuGet dependencies you can read docs on how to get started with Paket. When installed as global tool you can invoke it via paket CLI ** Yarn v2 is not yet supported Install an F# code editor You'll also want an IDE to create F# applications. We recommend one of the following great IDEs. VS Code + Ionide extension (support for Full Stack Debugging ) Visual Studio 2019 Jetbrains Rider Create your first SAFE app Create a new directory on your machine Open a command prompt Enter dotnet new -i SAFE.Template to install the SAFE project template Enter dotnet new SAFE to create a new SAFE project Enter fake build --target run to build and run the app Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically ; if you save a file in the server project it will also restart the server in the background. Take a look at the template options . There are several ways to customise the default application, such as server and client/server communication technologies. Troubleshooting Still have issues getting started? Check out the troubleshooting page.","title":"Quick Start"},{"location":"quickstart/#install-pre-requisites","text":"You'll need to install the following pre-requisites in order to build SAFE applications The .NET Core SDK 3.0 FAKE (>= 5.12) installed as global tool ( dotnet tool install -g fake-cli ) Paket installed as global tool ( dotnet tool install paket --add-source https://www.myget.org/F/paket-netcore-as-tool/api/v3/index.json -g ) (optional*) node.js (>= 8.0) yarn (>= 1.10.1**) or npm * You don't need Paket if you just want to try out SAFE. However if you need to edit NuGet dependencies you can read docs on how to get started with Paket. When installed as global tool you can invoke it via paket CLI ** Yarn v2 is not yet supported","title":"Install pre-requisites"},{"location":"quickstart/#install-an-f-code-editor","text":"You'll also want an IDE to create F# applications. We recommend one of the following great IDEs. VS Code + Ionide extension (support for Full Stack Debugging ) Visual Studio 2019 Jetbrains Rider","title":"Install an F# code editor"},{"location":"quickstart/#create-your-first-safe-app","text":"Create a new directory on your machine Open a command prompt Enter dotnet new -i SAFE.Template to install the SAFE project template Enter dotnet new SAFE to create a new SAFE project Enter fake build --target run to build and run the app Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically ; if you save a file in the server project it will also restart the server in the background. Take a look at the template options . There are several ways to customise the default application, such as server and client/server communication technologies.","title":"Create your first SAFE app"},{"location":"quickstart/#troubleshooting","text":"Still have issues getting started? Check out the troubleshooting page.","title":"Troubleshooting"},{"location":"support/","text":"The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications. Compositional IT Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions. Lambda Factory Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow. Fuzzy Cloud Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others. The F# Community The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out. Social You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack or on the Functional Programming Slack . We'll be expanding this over time.","title":"Support"},{"location":"support/#compositional-it","text":"Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.","title":"Compositional IT"},{"location":"support/#lambda-factory","text":"Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.","title":"Lambda Factory"},{"location":"support/#fuzzy-cloud","text":"Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others.","title":"Fuzzy Cloud"},{"location":"support/#the-f-community","text":"The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.","title":"The F# Community"},{"location":"support/#social","text":"You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack or on the Functional Programming Slack . We'll be expanding this over time.","title":"Social"},{"location":"template-appservice/","text":"The SAFE template has the ability to deploy to Azure's App Service with minimum effort. This template mode will also create you an Application Insights account, linked to your web application. What is Azure App Service? The Azure App Service allows you to quickly build, deploy, and scale enterprise-grade web, mobile, and API apps running on any platform whilst meeting rigorous performance, scalability, security and compliance requirements using a fully-managed platform to perform infrastructure maintenance. It comes in a number of pricing plans, including a free option and has options for scale-up, scale-out, turn-key authentication as well as powerful monitoring capabilities. It is compatible with many runtimes and includes excellent support for both .NET Framework and .NET Core. Deployment Steps In order to deploy your SAFE application to the App Service, you must have first created an Azure Account , selected a Subscription ID and created an associated App Registration . Custom FAKE build tasks The Azure variant of the SAFE template adds the following extra build stages: Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. ArmTemplate - Deploys an Azure Resource Manager (ARM) template containing an entire environment as required by the SAFE application. AppService - Zips up the bundled folder and deploys it into the created environment. There is a known issue that currently the FAKE script may sometimes fail the first time you run it with this error . If this occurs, simply open the FAKE script in your favourite editor, add a new line anywhere in the script, save and re-run. We're looking to fix this as soon as possible! What is an ARM template? An ARM template is a declarative JSON file which contains the details of the Azure resources you require in your environment. This might include a web application, database, VM and messaging service - essentially any service supported by Azure. ARM templates are smart, in that you can repeatedly deploy them over an existing environment and only the newly added elements in the template will be applied onto the environment - perfect for a CI / CD approach. This also allows you to create entire dev / test environments from scratch within just a few minutes. The ARM template that comes with the SAFE template includes everything you need for a complete deployment to Azure from a clean state. Build arguments Deploying your application through FAKE is relatively simple. Use the following command: fake build --target appservice -e subscriptionId=<subId> -e clientId=<clientId> -e tenantId=<tenantId> -e environment=<environment> (optional) -e location=<location> (optional) -e pricingTier=<pricingTier> (optional) where: subscriptionId is an Azure Subscription ID. clientId is the Application (Client) ID of an Azure App Registration. tenantId is the Directory (Tenant) ID of an Azure App Registration. environment is an optional environment name that will be appended to all Azure resources created, which allows you to create entire dev / test environments quickly and easily. This defaults to a random GUID. location is the Azure data center location you wish to use. There are currently over 30 different data centers worldwide. This defaults to westeurope ; the full list can be viewed here . The location must be supplied in lower case and without spaces. pricingTier is the pricing tier of the app service that hosts your SAFE app. This defaults to F1 (free); the full list can be viewed here . Note that you can also modify the FAKE script and embed both the subscriptionId , clientId and tenantId values directly in the script and commit into source control. This is completely safe to do as these values are not sufficient on their own to authenticate into Azure (see below). Interactive deployment When running the build script, you will need to interactively authenticate with Azure in order to deploy the ARM template. During the FAKE script, you will see the following midway through the build cycle: Navigating to that URL will request you to input the code shown above: Finally, you will be prompted sign into Azure using your normal user account, and possibly consent to granting permissions to the application. After a short delay, the FAKE script will continue. Note: If you're getting FileNotFoundException for Microsoft.Rest.ClientRuntime.Azure , try editing and rerunning FAKE script ( see details ). Creating a fully automated deployment You can also elect to implement a fully-automated (non-interactive) deployment model, ideal for Continuous Deployment (CD) scenarios through tools such as AppVeyor and Visual Studio Team Services, using an Azure Active Directory Application . In this model, in addition to a SubscriptionID and Client ID, you also supply a Tenant ID and an Application Secret into the FAKE script to deploy your ARM resources; these identities should normally be secured and supplied into your FAKE script as arguments rather than committed into source control. Viewing the deployed SAFE application Once the deployment is complete, you can log into the Azure Portal and see your environment being created. Log into the Azure Portal. Navigate to the Resource Groups blade and locate the newly-created group. Its name will be safe-<environment> e.g. safe-helloworld . Navigate to the App Service entry shown in the group following the convention safe-<environment>-web . Hit Browse from the new App Service blade that appears. Your application will be shown in the browser running on a url following the convention https://safe-<environment>-web.azurewebsites.net/ . You can also deploy to a Docker Container .","title":"Deploy to App Service"},{"location":"template-appservice/#what-is-azure-app-service","text":"The Azure App Service allows you to quickly build, deploy, and scale enterprise-grade web, mobile, and API apps running on any platform whilst meeting rigorous performance, scalability, security and compliance requirements using a fully-managed platform to perform infrastructure maintenance. It comes in a number of pricing plans, including a free option and has options for scale-up, scale-out, turn-key authentication as well as powerful monitoring capabilities. It is compatible with many runtimes and includes excellent support for both .NET Framework and .NET Core.","title":"What is Azure App Service?"},{"location":"template-appservice/#deployment-steps","text":"In order to deploy your SAFE application to the App Service, you must have first created an Azure Account , selected a Subscription ID and created an associated App Registration .","title":"Deployment Steps"},{"location":"template-appservice/#custom-fake-build-tasks","text":"The Azure variant of the SAFE template adds the following extra build stages: Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. ArmTemplate - Deploys an Azure Resource Manager (ARM) template containing an entire environment as required by the SAFE application. AppService - Zips up the bundled folder and deploys it into the created environment. There is a known issue that currently the FAKE script may sometimes fail the first time you run it with this error . If this occurs, simply open the FAKE script in your favourite editor, add a new line anywhere in the script, save and re-run. We're looking to fix this as soon as possible!","title":"Custom FAKE build tasks"},{"location":"template-appservice/#what-is-an-arm-template","text":"An ARM template is a declarative JSON file which contains the details of the Azure resources you require in your environment. This might include a web application, database, VM and messaging service - essentially any service supported by Azure. ARM templates are smart, in that you can repeatedly deploy them over an existing environment and only the newly added elements in the template will be applied onto the environment - perfect for a CI / CD approach. This also allows you to create entire dev / test environments from scratch within just a few minutes. The ARM template that comes with the SAFE template includes everything you need for a complete deployment to Azure from a clean state.","title":"What is an ARM template?"},{"location":"template-appservice/#build-arguments","text":"Deploying your application through FAKE is relatively simple. Use the following command: fake build --target appservice -e subscriptionId=<subId> -e clientId=<clientId> -e tenantId=<tenantId> -e environment=<environment> (optional) -e location=<location> (optional) -e pricingTier=<pricingTier> (optional) where: subscriptionId is an Azure Subscription ID. clientId is the Application (Client) ID of an Azure App Registration. tenantId is the Directory (Tenant) ID of an Azure App Registration. environment is an optional environment name that will be appended to all Azure resources created, which allows you to create entire dev / test environments quickly and easily. This defaults to a random GUID. location is the Azure data center location you wish to use. There are currently over 30 different data centers worldwide. This defaults to westeurope ; the full list can be viewed here . The location must be supplied in lower case and without spaces. pricingTier is the pricing tier of the app service that hosts your SAFE app. This defaults to F1 (free); the full list can be viewed here . Note that you can also modify the FAKE script and embed both the subscriptionId , clientId and tenantId values directly in the script and commit into source control. This is completely safe to do as these values are not sufficient on their own to authenticate into Azure (see below).","title":"Build arguments"},{"location":"template-appservice/#interactive-deployment","text":"When running the build script, you will need to interactively authenticate with Azure in order to deploy the ARM template. During the FAKE script, you will see the following midway through the build cycle: Navigating to that URL will request you to input the code shown above: Finally, you will be prompted sign into Azure using your normal user account, and possibly consent to granting permissions to the application. After a short delay, the FAKE script will continue. Note: If you're getting FileNotFoundException for Microsoft.Rest.ClientRuntime.Azure , try editing and rerunning FAKE script ( see details ).","title":"Interactive deployment"},{"location":"template-appservice/#creating-a-fully-automated-deployment","text":"You can also elect to implement a fully-automated (non-interactive) deployment model, ideal for Continuous Deployment (CD) scenarios through tools such as AppVeyor and Visual Studio Team Services, using an Azure Active Directory Application . In this model, in addition to a SubscriptionID and Client ID, you also supply a Tenant ID and an Application Secret into the FAKE script to deploy your ARM resources; these identities should normally be secured and supplied into your FAKE script as arguments rather than committed into source control.","title":"Creating a fully automated deployment"},{"location":"template-appservice/#viewing-the-deployed-safe-application","text":"Once the deployment is complete, you can log into the Azure Portal and see your environment being created. Log into the Azure Portal. Navigate to the Resource Groups blade and locate the newly-created group. Its name will be safe-<environment> e.g. safe-helloworld . Navigate to the App Service entry shown in the group following the convention safe-<environment>-web . Hit Browse from the new App Service blade that appears. Your application will be shown in the browser running on a url following the convention https://safe-<environment>-web.azurewebsites.net/ . You can also deploy to a Docker Container .","title":"Viewing the deployed SAFE application"},{"location":"template-azure-ai/","text":"What is Application Insights? Application Insights is an extensible Application Performance Management (APM) service for web developers on multiple platforms. You can use it to monitor your live web application; it will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app. It's designed to help you continuously improve performance and usability. Features of AI include: Request tracking : monitoring every request, timing and response, with full correlation of operations within a request. Dependency tracking : understand calls to third-party dependencies e.g. databases, web services etc. Failures : Understand which failures are occurring on your site, how often and with full stack traces. User behaviours : Understand user flows such as funnels and retention. Custom Events and Metrics : You can easily create arbitrary metrics and events using the Application Insights SDK for tracing and reporting. Reporting Capabilities : Either use Application Insights's built-in query language to create reports, or automatically export all data into a Storage Account for offline analytics. Basics of working with Application Insights Application Insights will automatically activate when you start running your SAFE application. You can locate your Application Insights instance directly from within your SAFE Resource Group in the Azure Portal, or from the \"Application Insights\" link in the SAFE App Service. From your Application Insights dashboard, you can drill down to trace all server requests: You can then drill into any specific request, such as the api/init route shown above, in order to see individual requests. From here, you can even track further into any individual call. AI has many more features, so it's worth reading the extensive documentation on the Azure website. How do SAFE apps integrate with Application Insights? Although Application Insights supports monitoring for both client and server, at the current time, the SAFE template only supports the server mode (although you can add support for client events yourself). Server-side support includes: Support in the bundled ARM template to create a free Application Insights instance along with your web application. Automatic configuration of your web application with connection details to the created Application Insights instance. Application support for activating Application Insights in code for e.g. custom events and metrics. AI integration is provided out-of-the-box in the template, since Giraffe uses the standard .NET Core Application Insights SDK in order to communicate with the Application Insights service. It uses the standard Application Insights middleware support for ASP .NET Core, which provides complete tracking of requests, dependencies, errors and live streaming.","title":"Application Insights Integration"},{"location":"template-azure-ai/#what-is-application-insights","text":"Application Insights is an extensible Application Performance Management (APM) service for web developers on multiple platforms. You can use it to monitor your live web application; it will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app. It's designed to help you continuously improve performance and usability. Features of AI include: Request tracking : monitoring every request, timing and response, with full correlation of operations within a request. Dependency tracking : understand calls to third-party dependencies e.g. databases, web services etc. Failures : Understand which failures are occurring on your site, how often and with full stack traces. User behaviours : Understand user flows such as funnels and retention. Custom Events and Metrics : You can easily create arbitrary metrics and events using the Application Insights SDK for tracing and reporting. Reporting Capabilities : Either use Application Insights's built-in query language to create reports, or automatically export all data into a Storage Account for offline analytics.","title":"What is Application Insights?"},{"location":"template-azure-ai/#basics-of-working-with-application-insights","text":"Application Insights will automatically activate when you start running your SAFE application. You can locate your Application Insights instance directly from within your SAFE Resource Group in the Azure Portal, or from the \"Application Insights\" link in the SAFE App Service. From your Application Insights dashboard, you can drill down to trace all server requests: You can then drill into any specific request, such as the api/init route shown above, in order to see individual requests. From here, you can even track further into any individual call. AI has many more features, so it's worth reading the extensive documentation on the Azure website.","title":"Basics of working with Application Insights"},{"location":"template-azure-ai/#how-do-safe-apps-integrate-with-application-insights","text":"Although Application Insights supports monitoring for both client and server, at the current time, the SAFE template only supports the server mode (although you can add support for client events yourself). Server-side support includes: Support in the bundled ARM template to create a free Application Insights instance along with your web application. Automatic configuration of your web application with connection details to the created Application Insights instance. Application support for activating Application Insights in code for e.g. custom events and metrics. AI integration is provided out-of-the-box in the template, since Giraffe uses the standard .NET Core Application Insights SDK in order to communicate with the Application Insights service. It uses the standard Application Insights middleware support for ASP .NET Core, which provides complete tracking of requests, dependencies, errors and live streaming.","title":"How do SAFE apps integrate with Application Insights?"},{"location":"template-azure-registration/","text":"In order to deploy applications to Azure from the FAKE script created by the SAFE template, you first need to create an Azure account and create an App Registration which allows remote deployments as a one-off task. This section explains how to do this. Creating an Azure Account You'll need to register for an Azure account. This can be achieved quickly and easily at https://azure.microsoft.com . New users are afforded a number of services for free for an entire year, including Azure SQL, Storage and VMs etc. Selecting a Subscription Once you have created your account, make a note of the Azure Subscription ID that you will deploy your SAFE applications into: Log in to your Azure Portal . Select All Services on the left-menu menu and locate Subscriptions in the blade on the right. Make a note of the Subscription ID of the subscription that you wish to deploy your application into. If you just created your Azure account, you'll most likely have a single subscription in the list. Creating an App Registration You now need to create an \"App Registration\" in your Azure Active Directory. This registration allows you to deploy an entire environment directly into Azure, complete with the deployed application, directly from a FAKE script. Create the application Navigate to the Azure Active Directory blade in the Portal. Select App registrations from the menu in the blade. Select New registration . Enter the Name of your application as any name e.g SAFE Deploy Set the Redirect URI as any URI e.g http://safe-stack.github.io/ Hit Register . Grant Permissions There are two ways of authenticating; the first (which we show here) is to use an \"impersonation\" model where you are required to explicitly log in to Azure as part of the deployment process. An alternative way is to use a \"Client Secret\" (which should never be committed into source control) to deploy the application in a non-interactive fashion. Choose API Permissions from the Manage group on the left menu. Choose Add a permission from the top menu in the new blade that appears. Choose Azure Service Management and hit Select . Check the user_impersonation option and hit Select . Hit Done from the Add API Access blade. Choose Authentication from the Manage group on the left menu. Ensure that Treat application as a public client is set to Yes . Hit Save . Copy configuration data Make a note of the Application (client) ID on the blade. Make a note of the Directory (tenant) ID on the blade. Congratulations - you're now ready to use the SAFE FAKE template to perform remote deployments.","title":"Registering with Azure"},{"location":"template-azure-registration/#creating-an-azure-account","text":"You'll need to register for an Azure account. This can be achieved quickly and easily at https://azure.microsoft.com . New users are afforded a number of services for free for an entire year, including Azure SQL, Storage and VMs etc.","title":"Creating an Azure Account"},{"location":"template-azure-registration/#selecting-a-subscription","text":"Once you have created your account, make a note of the Azure Subscription ID that you will deploy your SAFE applications into: Log in to your Azure Portal . Select All Services on the left-menu menu and locate Subscriptions in the blade on the right. Make a note of the Subscription ID of the subscription that you wish to deploy your application into. If you just created your Azure account, you'll most likely have a single subscription in the list.","title":"Selecting a Subscription"},{"location":"template-azure-registration/#creating-an-app-registration","text":"You now need to create an \"App Registration\" in your Azure Active Directory. This registration allows you to deploy an entire environment directly into Azure, complete with the deployed application, directly from a FAKE script.","title":"Creating an App Registration"},{"location":"template-azure-registration/#create-the-application","text":"Navigate to the Azure Active Directory blade in the Portal. Select App registrations from the menu in the blade. Select New registration . Enter the Name of your application as any name e.g SAFE Deploy Set the Redirect URI as any URI e.g http://safe-stack.github.io/ Hit Register .","title":"Create the application"},{"location":"template-azure-registration/#grant-permissions","text":"There are two ways of authenticating; the first (which we show here) is to use an \"impersonation\" model where you are required to explicitly log in to Azure as part of the deployment process. An alternative way is to use a \"Client Secret\" (which should never be committed into source control) to deploy the application in a non-interactive fashion. Choose API Permissions from the Manage group on the left menu. Choose Add a permission from the top menu in the new blade that appears. Choose Azure Service Management and hit Select . Check the user_impersonation option and hit Select . Hit Done from the Add API Access blade. Choose Authentication from the Manage group on the left menu. Ensure that Treat application as a public client is set to Yes . Hit Save .","title":"Grant Permissions"},{"location":"template-azure-registration/#copy-configuration-data","text":"Make a note of the Application (client) ID on the blade. Make a note of the Directory (tenant) ID on the blade. Congratulations - you're now ready to use the SAFE FAKE template to perform remote deployments.","title":"Copy configuration data"},{"location":"template-docker/","text":"The SAFE template has the ability to easily create a Docker container. The details of the additions to the FAKE script are shown here. For this deployment option SAFE uses the Linux containers and therefore you need docker installed on your machine and configure it to run with Linux containers . Custom FAKE build tasks Bundle - all necessary artifacts for both Server and Client are collected for following Docker target. Docker - based on present Dockerfile , docker image is built and tagged using dockerUser and dockerImageName values from the script. Note: Before running the Docker target, make sure to modify the default dockerUser and dockerImageName values in script. Testing docker image locally Make sure you have docker installed and created the template with --deploy docker option Run fake build --target docker Run docker run -d -it -p 8085:8085 {dockerUser}/{dockerImageName} Navigate to {dockerHost}:8085 url Docker image The image is based on microsoft/dotnet:runtime . Entrypoint for the image is dotnet Server.dll (with /Server working directory). To allow incoming traffic, port 8085 is exposed. Release to Azure App Service The following part shows how to set up automatic deployment to Microsoft Azure . Currently, SAFE template doesn't contain additional FAKE build targets to deploy a Docker image directly to Azure, so you'll need to grab (and possibly adjust) additional FAKE \"Deploy\" target from SAFE BookStore build script. Following steps assume you've added the necessary build script fragments from SAFE BookStore. Docker Hub Create a new Docker Hub account and a new public repository on Docker Hub. Release script Create a file called release.cmd with the following content and configure your DockerHub credentials: @echo off cls fake build --target Deploy \"DockerLoginServer=docker.io\" \"DockerImageName=****\" \"DockerUser=****\" \"DockerPassword=***\" %* Don't worry the file is already in .gitignore so your password will not be commited. Initial docker push In order to release a container you need to create a new entry in [RELEASE_NOTES.md] and run release.cmd . This will build the server and client, run all test, put the app into a docker container and push it to your docker hub repo. Azure Portal Go to the Azure Portal and create a new \"Web App for Containers\". Configure the Web App to point to the docker public repository and type in an image and tag. Also look for the \"Webhook Url\" on the portal (It is available in Settings/Container Settings of your deployed app), copy that url and set it as new trigger in your Docker Hub repo. Note that startup command is not necessary. The Dockerfile used to create the docker image exposes port 8085 for the Giraffe server application. This port needs to be mapped to port 80 within the Azure App Service for the application to receive http traffic. Presently this can only be done using the Azure CLI. You can do this easily in Azure Cloud Shell (accessible from the Azure Portal in the top menu bar) using the following command: az webapp config appsettings set --resource-group <resource group name> --name <web app name> --settings WEBSITES_PORT=8085 The above command is effectively the same as running docker run -p 80:8085 <image name> . Now you should be able to reach the website on your yourapp.azurewebsites.net url. Further releases Now everything is set up. By creating new entries in [RELEASE_NOTES.md] and a new run of release.cmd the website should update automatically. Alternatively, you can use the ARM deploy option to do automatic deployment to the Azure App Service platform.","title":"Deploy to Docker"},{"location":"template-docker/#custom-fake-build-tasks","text":"Bundle - all necessary artifacts for both Server and Client are collected for following Docker target. Docker - based on present Dockerfile , docker image is built and tagged using dockerUser and dockerImageName values from the script. Note: Before running the Docker target, make sure to modify the default dockerUser and dockerImageName values in script.","title":"Custom FAKE build tasks"},{"location":"template-docker/#testing-docker-image-locally","text":"Make sure you have docker installed and created the template with --deploy docker option Run fake build --target docker Run docker run -d -it -p 8085:8085 {dockerUser}/{dockerImageName} Navigate to {dockerHost}:8085 url","title":"Testing docker image locally"},{"location":"template-docker/#docker-image","text":"The image is based on microsoft/dotnet:runtime . Entrypoint for the image is dotnet Server.dll (with /Server working directory). To allow incoming traffic, port 8085 is exposed.","title":"Docker image"},{"location":"template-docker/#release-to-azure-app-service","text":"The following part shows how to set up automatic deployment to Microsoft Azure . Currently, SAFE template doesn't contain additional FAKE build targets to deploy a Docker image directly to Azure, so you'll need to grab (and possibly adjust) additional FAKE \"Deploy\" target from SAFE BookStore build script. Following steps assume you've added the necessary build script fragments from SAFE BookStore.","title":"Release to Azure App Service"},{"location":"template-docker/#docker-hub","text":"Create a new Docker Hub account and a new public repository on Docker Hub.","title":"Docker Hub"},{"location":"template-docker/#release-script","text":"Create a file called release.cmd with the following content and configure your DockerHub credentials: @echo off cls fake build --target Deploy \"DockerLoginServer=docker.io\" \"DockerImageName=****\" \"DockerUser=****\" \"DockerPassword=***\" %* Don't worry the file is already in .gitignore so your password will not be commited.","title":"Release script"},{"location":"template-docker/#initial-docker-push","text":"In order to release a container you need to create a new entry in [RELEASE_NOTES.md] and run release.cmd . This will build the server and client, run all test, put the app into a docker container and push it to your docker hub repo.","title":"Initial docker push"},{"location":"template-docker/#azure-portal","text":"Go to the Azure Portal and create a new \"Web App for Containers\". Configure the Web App to point to the docker public repository and type in an image and tag. Also look for the \"Webhook Url\" on the portal (It is available in Settings/Container Settings of your deployed app), copy that url and set it as new trigger in your Docker Hub repo. Note that startup command is not necessary. The Dockerfile used to create the docker image exposes port 8085 for the Giraffe server application. This port needs to be mapped to port 80 within the Azure App Service for the application to receive http traffic. Presently this can only be done using the Azure CLI. You can do this easily in Azure Cloud Shell (accessible from the Azure Portal in the top menu bar) using the following command: az webapp config appsettings set --resource-group <resource group name> --name <web app name> --settings WEBSITES_PORT=8085 The above command is effectively the same as running docker run -p 80:8085 <image name> . Now you should be able to reach the website on your yourapp.azurewebsites.net url.","title":"Azure Portal"},{"location":"template-docker/#further-releases","text":"Now everything is set up. By creating new entries in [RELEASE_NOTES.md] and a new run of release.cmd the website should update automatically. Alternatively, you can use the ARM deploy option to do automatic deployment to the Azure App Service platform.","title":"Further releases"},{"location":"template-fake/","text":"The template uses FAKE to build the application. Generated FAKE script consist of two primary build targets, used for different purposes: \"Run\" target Enter fake build --target run to build and run the app This target is used for development purposes, and provides a great live-reload experience. It consists of following steps: InstallClient - same as above in Build chain, RestoreServer - dotnet restore is invoked for Server to fetch all necessary packages (note dotnet build is skipped here), Run - most interesting part; in this step 3 separate actions are performed in parallel: dotnet watch run for Server side - compiles, runs Server and watches for changes in Server source files. Whenever a change in any source file is detected, Server is automatically stopped, recompiled and rerun in the background, dotnet fable webpack-dev-server for Client side - compiles Client to JavaScript and runs Webpack dev-server - this in turn recompiles and reloads the client application upon any source file change in Client project, New process is started for http://localhost:8080 to open the URL in default browser \"Build\" target This target is a standard build procedure, consisting of following steps: InstallDotNetCore - here, a required version of dotnet core is read from global.json file and if not yet installed, the script downloads and performs the installation of desired dotnet core SDK. InstallClient - in this step, either NPM or Yarn is invoked (based on which option was chosen when generating project) and it installs all Client dependencies defined in package.json . The step also performs dotnet restore to fetch NuGet-based packages used by front-end. Build - for server side dotnet build command is invoked, and for client side a special dotnet-fable CLI tool using dotnet fable webpack command with -p flag to compile Client project to a single JavaScript bundle file. Note: Extra build steps will be included if you specified the --deploy docker or --deploy azure flag when creating your project. For specific build parameters, go to one of the Deployment Options pages in the menu.","title":"Run and Build the app"},{"location":"template-fake/#run-target","text":"Enter fake build --target run to build and run the app This target is used for development purposes, and provides a great live-reload experience. It consists of following steps: InstallClient - same as above in Build chain, RestoreServer - dotnet restore is invoked for Server to fetch all necessary packages (note dotnet build is skipped here), Run - most interesting part; in this step 3 separate actions are performed in parallel: dotnet watch run for Server side - compiles, runs Server and watches for changes in Server source files. Whenever a change in any source file is detected, Server is automatically stopped, recompiled and rerun in the background, dotnet fable webpack-dev-server for Client side - compiles Client to JavaScript and runs Webpack dev-server - this in turn recompiles and reloads the client application upon any source file change in Client project, New process is started for http://localhost:8080 to open the URL in default browser","title":"\"Run\" target"},{"location":"template-fake/#build-target","text":"This target is a standard build procedure, consisting of following steps: InstallDotNetCore - here, a required version of dotnet core is read from global.json file and if not yet installed, the script downloads and performs the installation of desired dotnet core SDK. InstallClient - in this step, either NPM or Yarn is invoked (based on which option was chosen when generating project) and it installs all Client dependencies defined in package.json . The step also performs dotnet restore to fetch NuGet-based packages used by front-end. Build - for server side dotnet build command is invoked, and for client side a special dotnet-fable CLI tool using dotnet fable webpack command with -p flag to compile Client project to a single JavaScript bundle file. Note: Extra build steps will be included if you specified the --deploy docker or --deploy azure flag when creating your project. For specific build parameters, go to one of the Deployment Options pages in the menu.","title":"\"Build\" target"},{"location":"template-gcp-appengine/","text":"The SAFE template has the ability to deploy to AppEngine on Google Cloud Platform, GCP, with minimum effort. The deployment relies on AppEngine's flex deployment, that is, it is deploying a docker container. Quickstart First make sure you have gcloud cli tool configured . If you are already familiar with GCP and have gcloud in place, all you need to do to get started is: dotnet new SAFE --deploy gcp-appengine gcloud app create fake build -t Deploy gcloud app browse What is AppEngine Google Cloud AppEngine is a fully managed serverless application platform. AppEngine supports an environment that is called flexible environment . The flexible environment has native support for many different languages, and also an option of creating a custom environment. Even though .NET is supported, it is limited and focus on aspnet core, so the AppEngine support for SAFE is currently using the custom runtime for more flexibility. Pricing for AppEngine depends on the size of and the number of machines you use. Deployment steps Before you can deploy your AppEngine app you need to create a Google Cloud Platform account , set up the gcloud CLI tool and enable billing . Custom FAKE build tasks Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. Deploy - Invokes the gcloud command to deploy to AppEngine. How is deploy done? The deploy to AppEngine is not to complicated. The deploy leverage the fact that the AppEngine flex environment allows for custom runtimes. What that mean is that you basically can deploy an app that is defined by a docker container. In its simplest form you just need to have a Dockerfile present that defines the container and that will be built during deploy, and that is exactly how the deploy in this template is configured. We have a app.yaml file, that is used to configure your AppEngine app, and there we define runtime and also environment variables for the app. The Deploy task in the FAKE script invokes gcloud app deploy --quiet , which will deploy the app to the active google cloud project using the definition in the app.yaml and Dockerfile . Viewing the app When deploy is done the app will be publicly available, and all you need to do to access the app is to run gcloud app browse . Things to consider The main focus for the AppEngine template is to get you started. Exactly how you want to do the deployment depends on what your deployment process look like. For a small and simple app what you get here might be enough, but for a more complex scenario you might want to build the docker container separately and publish that to a container registry before running the actual deploy command. That makes it possible to disconnect the actual deploy of the container from the build of the container. The application also has health and liveliness checks disabled, and that is something you might want to enable again in app.yaml and also implement it in your app. The health and liveliness checks is a feature of AppEngine to make sure your app is running as expected.","title":"Deploy to Google Cloud AppEngine"},{"location":"template-gcp-appengine/#quickstart","text":"First make sure you have gcloud cli tool configured . If you are already familiar with GCP and have gcloud in place, all you need to do to get started is: dotnet new SAFE --deploy gcp-appengine gcloud app create fake build -t Deploy gcloud app browse","title":"Quickstart"},{"location":"template-gcp-appengine/#what-is-appengine","text":"Google Cloud AppEngine is a fully managed serverless application platform. AppEngine supports an environment that is called flexible environment . The flexible environment has native support for many different languages, and also an option of creating a custom environment. Even though .NET is supported, it is limited and focus on aspnet core, so the AppEngine support for SAFE is currently using the custom runtime for more flexibility. Pricing for AppEngine depends on the size of and the number of machines you use.","title":"What is AppEngine"},{"location":"template-gcp-appengine/#deployment-steps","text":"Before you can deploy your AppEngine app you need to create a Google Cloud Platform account , set up the gcloud CLI tool and enable billing .","title":"Deployment steps"},{"location":"template-gcp-appengine/#custom-fake-build-tasks","text":"Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. Deploy - Invokes the gcloud command to deploy to AppEngine.","title":"Custom FAKE build tasks"},{"location":"template-gcp-appengine/#how-is-deploy-done","text":"The deploy to AppEngine is not to complicated. The deploy leverage the fact that the AppEngine flex environment allows for custom runtimes. What that mean is that you basically can deploy an app that is defined by a docker container. In its simplest form you just need to have a Dockerfile present that defines the container and that will be built during deploy, and that is exactly how the deploy in this template is configured. We have a app.yaml file, that is used to configure your AppEngine app, and there we define runtime and also environment variables for the app. The Deploy task in the FAKE script invokes gcloud app deploy --quiet , which will deploy the app to the active google cloud project using the definition in the app.yaml and Dockerfile .","title":"How is deploy done?"},{"location":"template-gcp-appengine/#viewing-the-app","text":"When deploy is done the app will be publicly available, and all you need to do to access the app is to run gcloud app browse .","title":"Viewing the app"},{"location":"template-gcp-appengine/#things-to-consider","text":"The main focus for the AppEngine template is to get you started. Exactly how you want to do the deployment depends on what your deployment process look like. For a small and simple app what you get here might be enough, but for a more complex scenario you might want to build the docker container separately and publish that to a container registry before running the actual deploy command. That makes it possible to disconnect the actual deploy of the container from the build of the container. The application also has health and liveliness checks disabled, and that is something you might want to enable again in app.yaml and also implement it in your app. The health and liveliness checks is a feature of AppEngine to make sure your app is running as expected.","title":"Things to consider"},{"location":"template-gcp-kubernetes/","text":"The SAFE template has the ability to deploy to Kubernetes Engine on Google Cloud Platform, GCP, with minimum effort. The focus of the template is to set up the basic building blocks like creating the container, publishing the container and also create a simple deployment on kubernetes that exposes a kubernetes service. You probably want to, and should, add things like a proper hostname and https support. That can be done in multiple ways and is more of a kubernetes specific task than a SAFE task. Quickstart If you are familiar with GCP and already have gcloud and kubectl configured and an existing kubernetes cluster all you need to do to get started is running these commands: dotnet new SAFE --deploy gcp-kubernetes fake build -t Deploy The quickstart assumes you have a default zone configured, and it will deploy to a cluster named safe-cluster . To change the cluster add -e SAFE_CLUSTER=<kubernetes cluster> to the fake command. To get the exposed IP you need to run the following command: kubectl get service safe-template What is Kubernetes Engine Kubernetes Engine is a managed, production-ready environment for deploying containerized applications on Google Cloud Platform. Compared to AppEngine you will get faster deploy, but it also comes at a cost of higher operational cost. Total cost might be lower though depending on how many apps you run and how large your cluster is. One cluster can often host multiple apps, while each AppEngine app requires a single machine so with many apps AppEngine might be more expensive. Covering Kubernetes and Kubernetes Engine in greater detail is too large of a topic in this context, and there are a lot of tutorials on those topics available. Deployment steps Before you can deploy your Kubernetes Engine app you need to create a Google Cloud Platform account , set up the gcloud CLI tool and enable billing . The kubernetes deploy also rely on Google Cloud Container Registry, and you also need to authenticate with the registry. How that is done is described here: https://cloud.google.com/container-registry/docs/advanced-authentication . Creating your cluster and installing kubectl To make some of the commands easier we first set a default zone that will be used by the gcloud command, both here and from the build script. gcloud config set compute/zone europe-west1-b You can change the zone to a zone closer to where you live, https://cloud.google.com/compute/docs/regions-zones/ . Next up you need to create your kubernetes cluster. To create a cluster where the nodes are using of the free tier computing resources you can use this command: gcloud container clusters create safe-cluster --num-nodes=3 -m f1-micro To interact with the kubernetes cluster you also need to install kubectl . To get the correct version, that is, guaranteed to work with kubernetes engine, it is recommended to install it using gcloud : gcloud components install kubectl With this configured and installed you should be good to go. Custom FAKE build tasks Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. Docker - Based on present the Dockerfile a docker container image is built and tagged using the current google cloud project, name of the app and git hash. Publish - Publish the docker container image from the Docker task that matches the current git hash. ClusterAuth - Authenticates against the Google Cloud Kubernetes Cluster Deploy - Invokes kubectl to either deploy and expose the app or update the docker image for the deployment. How is deploy done? The actual deploy is the simplest possible deploy you can do on a kubernetes cluster. When the Deploy target runs it first checks if the deploy exists or not. If the deploy doesn't exist it will invoke the kubectl run <name> --image=<image name> --port <port> command. That oneline command will create a kubernetes pod , a service , a deployment and also exposing the service. If the deployment already exists instead of deploying the container an update to the image of the pod will be made by running kubectl set image ... . The container image that is used is the one that has been published to Google Cloud Container Registry in the Publish step. This is just to make it easier to deploy when everything is on the same platform. Viewing the app No hostname is created during the deploy, and no reverse proxy is configured either, so to view the app you need to get the exposed service external IP: kubectl get service safe-template Gotchas When you deploy a container to a kubernetes cluster using the container name and tag you might not get an updated version of the contaienr if you use the same tag. The easiest way to change the tag using the default template is to change the getDockerTag function in build.fsx . One common way to create the tag is to use the git sha, given that you use git. To do so you can change the getDockerTag to something like below: let getDockerTag projectName = let gitHash = Information.getCurrentHash() let projectId = getGcloudProject() sprintf \"gcr.io/%s/%s:%s\" projectId projectName gitHash to be sure you get a new docker tag you have to make a commit. Things to consider As mentioned in the beginning, this template is meant to get you started. You will need to configure https, hostnames and other things most likely. There are too many options to consider there to include it in this template, and you might have already invested in some of those options.","title":"Deploy to Google Cloud Kubernetes Engine"},{"location":"template-gcp-kubernetes/#quickstart","text":"If you are familiar with GCP and already have gcloud and kubectl configured and an existing kubernetes cluster all you need to do to get started is running these commands: dotnet new SAFE --deploy gcp-kubernetes fake build -t Deploy The quickstart assumes you have a default zone configured, and it will deploy to a cluster named safe-cluster . To change the cluster add -e SAFE_CLUSTER=<kubernetes cluster> to the fake command. To get the exposed IP you need to run the following command: kubectl get service safe-template","title":"Quickstart"},{"location":"template-gcp-kubernetes/#what-is-kubernetes-engine","text":"Kubernetes Engine is a managed, production-ready environment for deploying containerized applications on Google Cloud Platform. Compared to AppEngine you will get faster deploy, but it also comes at a cost of higher operational cost. Total cost might be lower though depending on how many apps you run and how large your cluster is. One cluster can often host multiple apps, while each AppEngine app requires a single machine so with many apps AppEngine might be more expensive. Covering Kubernetes and Kubernetes Engine in greater detail is too large of a topic in this context, and there are a lot of tutorials on those topics available.","title":"What is Kubernetes Engine"},{"location":"template-gcp-kubernetes/#deployment-steps","text":"Before you can deploy your Kubernetes Engine app you need to create a Google Cloud Platform account , set up the gcloud CLI tool and enable billing . The kubernetes deploy also rely on Google Cloud Container Registry, and you also need to authenticate with the registry. How that is done is described here: https://cloud.google.com/container-registry/docs/advanced-authentication .","title":"Deployment steps"},{"location":"template-gcp-kubernetes/#creating-your-cluster-and-installing-kubectl","text":"To make some of the commands easier we first set a default zone that will be used by the gcloud command, both here and from the build script. gcloud config set compute/zone europe-west1-b You can change the zone to a zone closer to where you live, https://cloud.google.com/compute/docs/regions-zones/ . Next up you need to create your kubernetes cluster. To create a cluster where the nodes are using of the free tier computing resources you can use this command: gcloud container clusters create safe-cluster --num-nodes=3 -m f1-micro To interact with the kubernetes cluster you also need to install kubectl . To get the correct version, that is, guaranteed to work with kubernetes engine, it is recommended to install it using gcloud : gcloud components install kubectl With this configured and installed you should be good to go.","title":"Creating your cluster and installing kubectl"},{"location":"template-gcp-kubernetes/#custom-fake-build-tasks","text":"Bundle - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder. Docker - Based on present the Dockerfile a docker container image is built and tagged using the current google cloud project, name of the app and git hash. Publish - Publish the docker container image from the Docker task that matches the current git hash. ClusterAuth - Authenticates against the Google Cloud Kubernetes Cluster Deploy - Invokes kubectl to either deploy and expose the app or update the docker image for the deployment.","title":"Custom FAKE build tasks"},{"location":"template-gcp-kubernetes/#how-is-deploy-done","text":"The actual deploy is the simplest possible deploy you can do on a kubernetes cluster. When the Deploy target runs it first checks if the deploy exists or not. If the deploy doesn't exist it will invoke the kubectl run <name> --image=<image name> --port <port> command. That oneline command will create a kubernetes pod , a service , a deployment and also exposing the service. If the deployment already exists instead of deploying the container an update to the image of the pod will be made by running kubectl set image ... . The container image that is used is the one that has been published to Google Cloud Container Registry in the Publish step. This is just to make it easier to deploy when everything is on the same platform.","title":"How is deploy done?"},{"location":"template-gcp-kubernetes/#viewing-the-app","text":"No hostname is created during the deploy, and no reverse proxy is configured either, so to view the app you need to get the exposed service external IP: kubectl get service safe-template","title":"Viewing the app"},{"location":"template-gcp-kubernetes/#gotchas","text":"When you deploy a container to a kubernetes cluster using the container name and tag you might not get an updated version of the contaienr if you use the same tag. The easiest way to change the tag using the default template is to change the getDockerTag function in build.fsx . One common way to create the tag is to use the git sha, given that you use git. To do so you can change the getDockerTag to something like below: let getDockerTag projectName = let gitHash = Information.getCurrentHash() let projectId = getGcloudProject() sprintf \"gcr.io/%s/%s:%s\" projectId projectName gitHash to be sure you get a new docker tag you have to make a commit.","title":"Gotchas"},{"location":"template-gcp-kubernetes/#things-to-consider","text":"As mentioned in the beginning, this template is meant to get you started. You will need to configure https, hostnames and other things most likely. There are too many options to consider there to include it in this template, and you might have already invested in some of those options.","title":"Things to consider"},{"location":"template-google-cloud/","text":"In order to deploy to Google Cloud Platform, GCP, you first need to create a google cloud project. Creating an account Creating an account is simple and you get some free credits when you sign up try GCP out. Go to https://cloud.google.com/ to sign up for an account. Creating a project A project on GCP is used to organize resources that belongs together one way or another. Creating a project is as simple as just clicking a button an write down the name of the project. If your project name is unique across GCP it will also be your project id , but if there are more than one project named the same you need to figure out your project id . You find the project id in the Home dashboard in the GCP console. Setup gcloud CLI tool The command line interface for GCP is what most people use to interact with the platform instead of clicking in the UI. To get started with the tool you need to install it following the instructions here: https://cloud.google.com/sdk/install . When you have installed gcloud you need to authenticate and also set the default project to work with: Authenticate: gcloud auth login Set project: gcloud config set project PROJECT_ID Try it for free! Google cloud give new users $300 to spend on cloud computing over a 12 month period from when you sign up. In addition to that you also get some free computing resources every month so you can test new things. However, you still need to enable billing and add a credit card to verify who you are. Read more about the Google Cloud Platform Free Tier . As mentioned, you still need to add a credit card to your billing account and this is the way to go about it. Go to Billing and create a billing account, you might have your free credits here already. When the billing account is created go back to the Home dashboard and then select Billing again in the menu. The reason for this is that you first created a billing account that can be used in many projects, but now you also need to link your project to that billing account. On the billing page just click Link a billing account and link your project to the newly created billing account.","title":"Registering with Google Cloud"},{"location":"template-google-cloud/#creating-an-account","text":"Creating an account is simple and you get some free credits when you sign up try GCP out. Go to https://cloud.google.com/ to sign up for an account.","title":"Creating an account"},{"location":"template-google-cloud/#creating-a-project","text":"A project on GCP is used to organize resources that belongs together one way or another. Creating a project is as simple as just clicking a button an write down the name of the project. If your project name is unique across GCP it will also be your project id , but if there are more than one project named the same you need to figure out your project id . You find the project id in the Home dashboard in the GCP console.","title":"Creating a project"},{"location":"template-google-cloud/#setup-gcloud-cli-tool","text":"The command line interface for GCP is what most people use to interact with the platform instead of clicking in the UI. To get started with the tool you need to install it following the instructions here: https://cloud.google.com/sdk/install . When you have installed gcloud you need to authenticate and also set the default project to work with: Authenticate: gcloud auth login Set project: gcloud config set project PROJECT_ID","title":"Setup gcloud CLI tool"},{"location":"template-google-cloud/#try-it-for-free","text":"Google cloud give new users $300 to spend on cloud computing over a 12 month period from when you sign up. In addition to that you also get some free computing resources every month so you can test new things. However, you still need to enable billing and add a credit card to verify who you are. Read more about the Google Cloud Platform Free Tier . As mentioned, you still need to add a credit card to your billing account and this is the way to go about it. Go to Billing and create a billing account, you might have your free credits here already. When the billing account is created go back to the Home dashboard and then select Billing again in the menu. The reason for this is that you first created a billing account that can be used in many projects, but now you also need to link your project to that billing account. On the billing page just click Link a billing account and link your project to the newly created billing account.","title":"Try it for free!"},{"location":"template-heroku/","text":"In order to deploy to Heroku, you first need to create a Heroku account and download Heroku CLI. Creating an account Creating an account is simple and free. Go to https://signup.heroku.com/ to sign up for an account. Setup Heroku CLI tool The command line interface for Heroku is what the template uses to interact with the platform and create the projects. To get started with the tool you need to install it following the instructions here: https://devcenter.heroku.com/articles/heroku-cli . When you have installed heroku you need to authenticate: Authenticate: heroku login Quickstart After installing Heroku CLI and authenticating, the template makes the process of creating, configuring and deploying the project very straightforward: dotnet new SAFE --deploy heroku fake build -t Configure <optional app:create arguments> fake build -t Deploy After these steps if everything went right, the project should open on the browser. How is deploy done? When you are ready to deploy, you need to add your changes to git staging area and create a commit. After you push your changes, Heroku will compile the project using the Bundle target, creating a Procfile that tells the instance what command it will need to run. Custom FAKE build tasks Configure - Needs to be run only once when creating the project. Makes the following configurations: Creates the project using the heroku apps:create command. If no argument is supplied, heroku generates a random name for the project, otherwise it tries to use the supplied name. Initializes the current folder as a Git repository and commits everything. Links the created repository to the project's remote git. Configures the buildpack that compiles and run the project on heroku's server. Deploy - Serves as an shortcut for git push heroku master . Uploads the current commit to the server so it can be deployed.","title":"Deploy to Heroku"},{"location":"template-heroku/#creating-an-account","text":"Creating an account is simple and free. Go to https://signup.heroku.com/ to sign up for an account.","title":"Creating an account"},{"location":"template-heroku/#setup-heroku-cli-tool","text":"The command line interface for Heroku is what the template uses to interact with the platform and create the projects. To get started with the tool you need to install it following the instructions here: https://devcenter.heroku.com/articles/heroku-cli . When you have installed heroku you need to authenticate: Authenticate: heroku login","title":"Setup Heroku CLI tool"},{"location":"template-heroku/#quickstart","text":"After installing Heroku CLI and authenticating, the template makes the process of creating, configuring and deploying the project very straightforward: dotnet new SAFE --deploy heroku fake build -t Configure <optional app:create arguments> fake build -t Deploy After these steps if everything went right, the project should open on the browser.","title":"Quickstart"},{"location":"template-heroku/#how-is-deploy-done","text":"When you are ready to deploy, you need to add your changes to git staging area and create a commit. After you push your changes, Heroku will compile the project using the Bundle target, creating a Procfile that tells the instance what command it will need to run.","title":"How is deploy done?"},{"location":"template-heroku/#custom-fake-build-tasks","text":"Configure - Needs to be run only once when creating the project. Makes the following configurations: Creates the project using the heroku apps:create command. If no argument is supplied, heroku generates a random name for the project, otherwise it tries to use the supplied name. Initializes the current folder as a Git repository and commits everything. Links the created repository to the project's remote git. Configures the buildpack that compiles and run the project on heroku's server. Deploy - Serves as an shortcut for git push heroku master . Uploads the current commit to the server so it can be deployed.","title":"Custom FAKE build tasks"},{"location":"template-iis/","text":"Deploy to IIS The SAFE template can be easily deployed to IIS , either on-premise or on a hosted virtual machine running Windows. To get started, scaffold the template with the deploy option set to IIS: dotnet new SAFE --deploy iis The template will include a custom FAKE build target called Bundle to package your application and make it ready for deployment, run this target using: fake build --target bundle When the target finishes running succesfully, you will have a new deploy directory with this structure: {template root} | | - deploy | - Client | - Server Your app is now ready for deployment. Setting up IIS Create an Application Pool Hosting dotnet core on IIS does not support Application Pool sharing which means every dotnet application has it's own application pool, create a new one, give it the name of the application, for example SafeApp and make sure to set the .NET CLR version to No Managed Code : Required IIS Modules: ASP.NET Core module for Giraffe and Saturn HttpPlatformHandler for Suave ASP.NET Core module Like with any dotnet core app hosted within IIS, you will need to have the AspNetCoreModule installed in IIS * . This is a native module that starts your dotnet app in a child process of IIS and proxies all http requests coming from IIS to the application. Note that for netcoreapp2.2, you will need AspNetCoreModule and not AspNetCoreModuleV2. HttpPlatformHandler (applies to Suave) Because Suave does not run on Kestrel, it does not use built-in IIS integration from ASP.NET Core, and therefore, Suave will use the generic HttpPlatformHandler module in IIS. Make sure you have the module installed on your IIS server: There is a catch when using Suave and HttpPlatformHandler: you cannot create sub-applications within an IIS website (root level application) because the virtual paths will break how the routing works in Suave, meaning that you have to add a new website for a Suave application. Another thing to considor when deploying Suave, is that you have to change a part your web.config manually, from this: <httpPlatform stdoutLogEnabled=\"true\" stdoutLogFile=\"suave.log\" startupTimeLimit=\"20\" processPath=\"dotnet\" arguments=\"./Server\" /> to this: <httpPlatform stdoutLogEnabled=\"true\" stdoutLogFile=\"suave.log\" startupTimeLimit=\"20\" processPath=\"dotnet\" arguments=\"C:\\full\\path\\to\\deployed\\Server.dll\" /> because otherwise the HttpPlatformHandler will not be able to figure out where the application exactly is. Add Application (applies to Giraffe and Saturn) Now that the application pool is setup, we can our application to it. When Adding an application, you give it an ailias, and a physical path. In our case, because this is the only application in the application pool, lets just name it SafeApp and the physical path of the application is the Server directory of the bundled deployment directory: {template root} | | - deploy | - Client | - Server <--- the physical path Here I am adding the application to the default (root) website of IIS Now your application should be up and running! Add Website (applies to Suave) Adding a website is the same as adding a sub-application, using a single application pool and having the physical path of the application be the Server directory of the bundled deployment directory: {template root} | | - deploy | - Client | - Server <--- the physical path but the difference is that now you have choose a different port for the application: for this example, I have chosen to run the application on port 8090 and web.config looks like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <system.webServer> <handlers> <remove name=\"httpplatformhandler\" /> <add name=\"httpplatformhandler\" path=\"*\" verb=\"*\" modules=\"httpPlatformHandler\" resourceType=\"Unspecified\" /> </handlers> <httpPlatform stdoutLogEnabled=\"true\" stdoutLogFile=\"suave.log\" startupTimeLimit=\"20\" processPath=\"dotnet\" arguments=\"C:\\projects\\SafeApp\\deploy\\Server\\Server.dll\" /> </system.webServer> </configuration> Notice how I am using the full path of the compiled Server.dll from my deployment directory. Now click OK and your Suave app should be up and running: Deploying a new version Stop the application pool Replace the contents of the deployment directory Restart/Recycle the application pool Client developement considorations (applies to Giraffe and Saturn) When hosting inside IIS, your application will most likely run inside a virtual path like in the above example. This means that requests made using fetch will not work by default: // will not work fetchAs<Customer list> \"/api/customers\" To solve this, the template includes a module ServerPath with a function to normalize the routes, so instead of the above you would have: // this works fetchAs<Customer list> (ServerPath.normalize \"/api/customers\") You will have to this for every request you make, unless you are using remoting which is done only once during proxy setup. Be careful not to forget ServerPath.normalize , because if you forget it during developement, the route still works because there is no IIS but then when you deploy the app, the route won't work any more because of the virtual paths.","title":"Deploy to IIS"},{"location":"template-iis/#deploy-to-iis","text":"The SAFE template can be easily deployed to IIS , either on-premise or on a hosted virtual machine running Windows. To get started, scaffold the template with the deploy option set to IIS: dotnet new SAFE --deploy iis The template will include a custom FAKE build target called Bundle to package your application and make it ready for deployment, run this target using: fake build --target bundle When the target finishes running succesfully, you will have a new deploy directory with this structure: {template root} | | - deploy | - Client | - Server Your app is now ready for deployment.","title":"Deploy to IIS"},{"location":"template-iis/#setting-up-iis","text":"","title":"Setting up IIS"},{"location":"template-iis/#create-an-application-pool","text":"Hosting dotnet core on IIS does not support Application Pool sharing which means every dotnet application has it's own application pool, create a new one, give it the name of the application, for example SafeApp and make sure to set the .NET CLR version to No Managed Code :","title":"Create an Application Pool"},{"location":"template-iis/#required-iis-modules","text":"ASP.NET Core module for Giraffe and Saturn HttpPlatformHandler for Suave","title":"Required IIS Modules:"},{"location":"template-iis/#aspnet-core-module","text":"Like with any dotnet core app hosted within IIS, you will need to have the AspNetCoreModule installed in IIS * . This is a native module that starts your dotnet app in a child process of IIS and proxies all http requests coming from IIS to the application. Note that for netcoreapp2.2, you will need AspNetCoreModule and not AspNetCoreModuleV2.","title":"ASP.NET Core module"},{"location":"template-iis/#httpplatformhandler-applies-to-suave","text":"Because Suave does not run on Kestrel, it does not use built-in IIS integration from ASP.NET Core, and therefore, Suave will use the generic HttpPlatformHandler module in IIS. Make sure you have the module installed on your IIS server: There is a catch when using Suave and HttpPlatformHandler: you cannot create sub-applications within an IIS website (root level application) because the virtual paths will break how the routing works in Suave, meaning that you have to add a new website for a Suave application. Another thing to considor when deploying Suave, is that you have to change a part your web.config manually, from this: <httpPlatform stdoutLogEnabled=\"true\" stdoutLogFile=\"suave.log\" startupTimeLimit=\"20\" processPath=\"dotnet\" arguments=\"./Server\" /> to this: <httpPlatform stdoutLogEnabled=\"true\" stdoutLogFile=\"suave.log\" startupTimeLimit=\"20\" processPath=\"dotnet\" arguments=\"C:\\full\\path\\to\\deployed\\Server.dll\" /> because otherwise the HttpPlatformHandler will not be able to figure out where the application exactly is.","title":"HttpPlatformHandler (applies to Suave)"},{"location":"template-iis/#add-application-applies-to-giraffe-and-saturn","text":"Now that the application pool is setup, we can our application to it. When Adding an application, you give it an ailias, and a physical path. In our case, because this is the only application in the application pool, lets just name it SafeApp and the physical path of the application is the Server directory of the bundled deployment directory: {template root} | | - deploy | - Client | - Server <--- the physical path Here I am adding the application to the default (root) website of IIS Now your application should be up and running!","title":"Add Application (applies to Giraffe and Saturn)"},{"location":"template-iis/#add-website-applies-to-suave","text":"Adding a website is the same as adding a sub-application, using a single application pool and having the physical path of the application be the Server directory of the bundled deployment directory: {template root} | | - deploy | - Client | - Server <--- the physical path but the difference is that now you have choose a different port for the application: for this example, I have chosen to run the application on port 8090 and web.config looks like this: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <system.webServer> <handlers> <remove name=\"httpplatformhandler\" /> <add name=\"httpplatformhandler\" path=\"*\" verb=\"*\" modules=\"httpPlatformHandler\" resourceType=\"Unspecified\" /> </handlers> <httpPlatform stdoutLogEnabled=\"true\" stdoutLogFile=\"suave.log\" startupTimeLimit=\"20\" processPath=\"dotnet\" arguments=\"C:\\projects\\SafeApp\\deploy\\Server\\Server.dll\" /> </system.webServer> </configuration> Notice how I am using the full path of the compiled Server.dll from my deployment directory. Now click OK and your Suave app should be up and running:","title":"Add Website (applies to Suave)"},{"location":"template-iis/#deploying-a-new-version","text":"Stop the application pool Replace the contents of the deployment directory Restart/Recycle the application pool","title":"Deploying a new version"},{"location":"template-iis/#client-developement-considorations-applies-to-giraffe-and-saturn","text":"When hosting inside IIS, your application will most likely run inside a virtual path like in the above example. This means that requests made using fetch will not work by default: // will not work fetchAs<Customer list> \"/api/customers\" To solve this, the template includes a module ServerPath with a function to normalize the routes, so instead of the above you would have: // this works fetchAs<Customer list> (ServerPath.normalize \"/api/customers\") You will have to this for every request you make, unless you are using remoting which is done only once during proxy setup. Be careful not to forget ServerPath.normalize , because if you forget it during developement, the route still works because there is no IIS but then when you deploy the app, the route won't work any more because of the virtual paths.","title":"Client developement considorations (applies to Giraffe and Saturn)"},{"location":"template-overview/","text":"The SAFE Template is a dotnet CLI template for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application. The template gets you up and running with the most common elements of the stack: Saturn or Giraffe Fable for client-side F# Elmish for web UI Fulma for consistent web styling Docker , Azure App Service , Google Cloud AppEngine , Google Cloud Kubernetes Engine or Heroku deployment models for hosting. Using the template Refer to the Quick Start guide to see basic guidance on how to install and use the template. Examples Create a SAFE application using all defaults: dotnet new SAFE Create a SAFE application using Giraffe with Fable Remoting: dotnet new SAFE --server giraffe --communication remoting Create a SAFE application using Giraffe with Fulma 'Landing' : dotnet new SAFE --server giraffe --layout fulma-landing Template options The template provides the ability to customise the created application. You can see template version and available options by running dotnet new SAFE --help . Server Configures the SAFE app to use one of two different back-end hosting platforms. Usage: dotnet new SAFE --server <server> Where <server> is one of: saturn : Creates a SAFE app running on Saturn on top of Giraffe (default) . giraffe : Creates a SAFE app running on Giraffe only. Layout Configures the SAFE app to apply a CSS Framework to the UI template. Currently supports just Fulma bindings Usage: dotnet new SAFE --layout <layout> Where <layout> is one of: none : don't add any CSS framework. fulma-basic : adds Fulma basic template (default) . fulma-admin : adds Fulma with the 'Admin' Bulma template. fulma-cover : adds Fulma with the 'Cover' Bulma template. fulma-hero : adds Fulma with the 'Hero' Bulma template. fulma-landing : adds Fulma with the 'Landing' Bulma template. fulma-login : adds Fulma with the 'Login' Bulma template. Communication Configures the SAFE app to use one of available means of communication between client and server. Currently supports Fable.Remoting and Elmish.Bridge . If this argument is not supplied, client / server communication will be handled through the standard routing and serialization mechanism of the server. See here for an overview of Fable.Remoting, Elmish.Bridge and the alternatives for sharing data between client and server. Usage: dotnet new SAFE --communication <communication model> Where <communication model> is one of: none : don't add any additional libraries for client-server communication (default) remoting : add Fable.Remoting to the template. bridge : add Elmish.Bridge to the template. Pattern Configures Client app to use one of available patterns. Currently supports only either default Elmish architecture with Commands or simple (no Commands) Elmish Architecture in conjunction with Elmish.Streams library for reactive programming Usage: dotnet new SAFE --pattern <pattern model> Where <pattern model> is one of: default : use standard Elmish architecture with Commands (default) streams : use simple Elmish architecture without Commands + Elmish.Streams for reactive pattern Deploy Optionally configures the SAFE app to elements needed for deploying to one of two different hosting models. If this argument is not supplied, no explicit support for any hosting model will be provided. Usage: dotnet new SAFE --deploy <hosting model> Where <hosting model> is one of: none : don't add FAKE targets to deploy (default) . docker : Adds FAKE targets that bundles and build a Docker image. See here for more details about Docker deployment. azure : Adds FAKE targets and an Azure Resource Manager (ARM) template that allows deployment to the Azure App Service plus an Azure Application Insights instance. See here for more details about Azure deployment. gcp-appengine : Adds FAKE targets to deploy to Google Cloud AppEngine . gcp-kubernetes : Adds FAKE targets to deploy to Google Cloud Kubernetes Engine . iis : Adds FAKE targets and client paths normalization to easily publish the application to IIS . heroku : Adds FAKE targets to deploy to Heroku . JS Deps Configures the SAFE app to use either Yarn or NPM for JS package management. Usage: dotnet new SAFE --js-deps <package manager> Where <package manager> is one of: yarn : uses Yarn for JS package management (default) . npm : uses NPM for JS package management. If you use NPM, you'll also need NPX to run scripts.","title":"Overview"},{"location":"template-overview/#using-the-template","text":"Refer to the Quick Start guide to see basic guidance on how to install and use the template.","title":"Using the template"},{"location":"template-overview/#examples","text":"Create a SAFE application using all defaults: dotnet new SAFE Create a SAFE application using Giraffe with Fable Remoting: dotnet new SAFE --server giraffe --communication remoting Create a SAFE application using Giraffe with Fulma 'Landing' : dotnet new SAFE --server giraffe --layout fulma-landing","title":"Examples"},{"location":"template-overview/#template-options","text":"The template provides the ability to customise the created application. You can see template version and available options by running dotnet new SAFE --help .","title":"Template options"},{"location":"template-overview/#server","text":"Configures the SAFE app to use one of two different back-end hosting platforms. Usage: dotnet new SAFE --server <server> Where <server> is one of: saturn : Creates a SAFE app running on Saturn on top of Giraffe (default) . giraffe : Creates a SAFE app running on Giraffe only.","title":"Server"},{"location":"template-overview/#layout","text":"Configures the SAFE app to apply a CSS Framework to the UI template. Currently supports just Fulma bindings Usage: dotnet new SAFE --layout <layout> Where <layout> is one of: none : don't add any CSS framework. fulma-basic : adds Fulma basic template (default) . fulma-admin : adds Fulma with the 'Admin' Bulma template. fulma-cover : adds Fulma with the 'Cover' Bulma template. fulma-hero : adds Fulma with the 'Hero' Bulma template. fulma-landing : adds Fulma with the 'Landing' Bulma template. fulma-login : adds Fulma with the 'Login' Bulma template.","title":"Layout"},{"location":"template-overview/#communication","text":"Configures the SAFE app to use one of available means of communication between client and server. Currently supports Fable.Remoting and Elmish.Bridge . If this argument is not supplied, client / server communication will be handled through the standard routing and serialization mechanism of the server. See here for an overview of Fable.Remoting, Elmish.Bridge and the alternatives for sharing data between client and server. Usage: dotnet new SAFE --communication <communication model> Where <communication model> is one of: none : don't add any additional libraries for client-server communication (default) remoting : add Fable.Remoting to the template. bridge : add Elmish.Bridge to the template.","title":"Communication"},{"location":"template-overview/#pattern","text":"Configures Client app to use one of available patterns. Currently supports only either default Elmish architecture with Commands or simple (no Commands) Elmish Architecture in conjunction with Elmish.Streams library for reactive programming Usage: dotnet new SAFE --pattern <pattern model> Where <pattern model> is one of: default : use standard Elmish architecture with Commands (default) streams : use simple Elmish architecture without Commands + Elmish.Streams for reactive pattern","title":"Pattern"},{"location":"template-overview/#deploy","text":"Optionally configures the SAFE app to elements needed for deploying to one of two different hosting models. If this argument is not supplied, no explicit support for any hosting model will be provided. Usage: dotnet new SAFE --deploy <hosting model> Where <hosting model> is one of: none : don't add FAKE targets to deploy (default) . docker : Adds FAKE targets that bundles and build a Docker image. See here for more details about Docker deployment. azure : Adds FAKE targets and an Azure Resource Manager (ARM) template that allows deployment to the Azure App Service plus an Azure Application Insights instance. See here for more details about Azure deployment. gcp-appengine : Adds FAKE targets to deploy to Google Cloud AppEngine . gcp-kubernetes : Adds FAKE targets to deploy to Google Cloud Kubernetes Engine . iis : Adds FAKE targets and client paths normalization to easily publish the application to IIS . heroku : Adds FAKE targets to deploy to Heroku .","title":"Deploy"},{"location":"template-overview/#js-deps","text":"Configures the SAFE app to use either Yarn or NPM for JS package management. Usage: dotnet new SAFE --js-deps <package manager> Where <package manager> is one of: yarn : uses Yarn for JS package management (default) . npm : uses NPM for JS package management. If you use NPM, you'll also need NPX to run scripts.","title":"JS Deps"},{"location":"template-webpack/","text":"Webpack Development Server and your Web Server Explain the webpack steps Explain port forwarding Explain static content","title":"Template webpack"},{"location":"template-webpack/#webpack-development-server-and-your-web-server","text":"Explain the webpack steps Explain port forwarding Explain static content","title":"Webpack Development Server and your Web Server"},{"location":"testimonials/","text":"Please feel free to submit a PR to add testimonials to this page! msu solutions GmbH SAFE gives us a fast development cycle for our web and mobile platforms We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with. Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. Especially the commercial support for SAFE is very important for us and our customers. Goswin Rothenthal It just works! The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure. Demetrix SAFE was the perfect place to start our biological design and data management platform Demetrix uses F# for DNA design and data management in our research pipeline. Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment. I would start with SAFE again in a heartbeat for a new project. We shared some of our experiences at Open F# 2018.","title":"Testimonials"},{"location":"testimonials/#msu-solutions-gmbh","text":"SAFE gives us a fast development cycle for our web and mobile platforms We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with. Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. Especially the commercial support for SAFE is very important for us and our customers.","title":"msu solutions GmbH"},{"location":"testimonials/#goswin-rothenthal","text":"It just works! The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure.","title":"Goswin Rothenthal"},{"location":"testimonials/#demetrix","text":"SAFE was the perfect place to start our biological design and data management platform Demetrix uses F# for DNA design and data management in our research pipeline. Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment. I would start with SAFE again in a heartbeat for a new project. We shared some of our experiences at Open F# 2018.","title":"Demetrix"}]}